# Introduction

**FhatOS** (pronounced _fat_) is
a [distributed operating system](https://en.wikipedia.org/wiki/Distributed_operating_system)
for [ESP8266](https://en.wikipedia.org/wiki/ESP8266) and [ESP32](https://en.wikipedia.org/wiki/ESP32) processors with
support for sandboxed deployments on Linux and MacOSX systems. All FhatOS resources, from individual datum, files,
processes exist within a single [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier) address space called
**furi** (pronounced "fury" or "fhat uri"). Processes communicate via a publish-subscribe message passing protocol that
rides atop [MQTT](https://en.wikipedia.org/wiki/MQTT) with various levels of access from thread local, to machine local
and ultimately, globally via cluster remote.

### Booting FhatOS

#### Booting on Linux/Unix/Mac

#### Booting on ESP32

#### Booting on ESP8266

### A FhatOS Language

FhatOS software can be written in C/C++ or mm-ADT (**multi-model abstract data type**). mm-ADT is a cluster-oriented
programming language and virtual machine founded on 5 _mono-types_ (`bool`, `int`, `real`, `uri`, and `str`)
and 2 _poly-types_ (**lst** and **rec**), where `rec` is a `lst` of 2-`obj` `lsts` with particular semantics regarding
key uniqueness. mm-ADT programs are sent via message to the FhatOS scheduler and then spawned
as a process accordingly. FhatOS provides a collection of device drivers and new device drivers can be written (
typically in C/C++). Provided drivers include pulse wave modulation, thermometer, gas, H-bridge, etc. sensors and
actuators.

A simple mm-ADT program is defined below. The program is a specialization of the poly-type `rec` called `thread`,
where `thread` is abstractly defined as

```.cpp
thread[[setup => __]
        loop  => __]]
```

<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "define(/int/nat,|is(gt(0)))" "nat[10]" "nat[-5]" "nat[5.0]" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,language="c++"]
----
fhatos> define(/int/nat,is(gt(0)))
fhatos> nat[10]
[ERROR]  int[nat[10]] unexpectedly acccessed for bcode_value [line:402]
fhatos> nat[-5]
[ERROR]  [/sys/lang/type/] -5 is not a /int/nat[is[gt[0]]]
fhatos> nat[5.0]
[ERROR]  [/sys/lang/type/] /real/nat is an undefined type
----
++++
<!-- OUTPUT:END -->

<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "define(/int/nat,is(gt(0)))" "define(/rec/person,[name=>as(/str/),age=>as(/int/nat)])" "person[[name=>'fhatty',age=>0]]" "person[[name=>'fhatty',age=>1]]" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,language="c++"]
----
fhatos> define(/int/nat,is(gt(0)))
fhatos> define(/rec/person,[name=>as(/str/),age=>as(/int/nat)])
fhatos> person[[name=>'fhatty',age=>0]]
[ERROR]  [/sys/lang/type/] 0 is not a /int/nat[is[gt[0]]]
fhatos> person[[name=>'fhatty',age=>1]]
[ERROR]  rec[person[[name=>'fhatty',age=>1]]] unexpectedly acccessed for bcode_value [line:402]
----
++++
<!-- OUTPUT:END -->


The `thread` object is published to the fURI endpoint `esp32@127.0.0.1/scheduler/threads/logger`. The scheduler spawns
the program on an individual `thread` accessible via the target fURI. Once spawned, the `setup` function prints the
thread's id and halts.

```.cpp
fhatos> thread[[setup => print('setup complete'),
                loop  => stop(/abc/)]].to(/abc/)
```

```.cpp
fhatos> */abc/
==> thread[[setup => print('setup complete'),
            loop  => stop(/abc/)]]
```

### A FhatOS Console

> [!note]
> The FhatOS Console is a composite of 3 other actors:
> 1. The `Terminal` (`/sys/io/terminal/`) provides thread-safe access to hardware I/O.
> 2. The `Parser` (`/sys/lang/parser/`) converts string input to bytecode output.
> 3. The `Processor` (`/sys/lang/processor/`) executes bytecode.

```
terminal/in =[str]=> console 
  =[str]=> parser =bcode<~/abc>=> 
    processor =[objs]=> ~/abc 
      <=[objs]= console 
        =[str]=> terminal/out
```

### fURI and MQTT

[MQTT](https://en.wikipedia.org/wiki/MQTT) is a publish/subscribe message passing protocol that has found extensive
usage in embedded systems. Hierarchically specified _topics_ can be _subscribed_ and _published_ to. In MQTT, there is
no direct communication between actors, though such behavior can be simulated if an actor's mailbox is a unique topic.
FhatOS leverages MQTT, but from the vantage point of URIs instead of topics with message routing being location-aware.
There exist three MQTT routers:

1. `MonadRouter`: An MQTT router scoped to an active monad (**thread**) processing a monoid (**program**).
2. `MonoidRouter`: An MQTT router scoped to a monoid (**program**).
3. `HostRouter`: An MQTT router scoped to the current host (**machine**).
4. `ClusterRouter`: An MQTT router scoped to the current intranet (**cluster**).
5. `GlobalRouter` : An MQTT router scoped to the Internet. 
6. `MetaRouter`: An MQTT router dynamically scoped to other routers based on fURI endpoints.

> [!note]
> * `abc` monad scoped fURI.
> * `~/abc` monoid scoped fURI ("home directory" of executing program).
> * `/abc` host scoped fURI (rooted at localhost).
> * `//abc` cluster scoped fURI (hosted on the intranet).
> * `//abc.org/` globally scoped fURI (hosted on the internet)

<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "__(1,2,3,4).plus(10)" "16.to(b)" "*b.plus(45)" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,language="c++"]
----
fhatos> __(1,2,3,4).plus(10)
==>11
==>12
==>13
==>14
fhatos> 16.to(b)
fhatos> *b.plus(45)
==>61
----
++++
<!-- OUTPUT:END -->

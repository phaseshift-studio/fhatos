:imagesdir: ./images
:favicon: {imagesdir}/fhatos-logo-small.png
:copyright: PhaseShift Studio
:author: üí© Dogturd Stynx
:email: dogturd.stynx@fhatos.org
:revnumber: 0.1
:tabsize: 2
:icons: font
:stem: latexmath
:source-highlighter: highlight.js
:highlightjsdir: ./highlight
:highlightjs-languages: mmadt, bash
:stylesheet: ./css/fhatos.css
:data-uri:
:toc-title: üêñ FhatOS
:toc: left
:toclevels: 4
:license-url: https://www.gnu.org/licenses/agpl-3.0.html
:license-title: AGPLv3
:lang: en
:docinfo: shared
:max-width: 75%
:app-name: FhatOS
:version-label: 0.1-alpha
:docname: FhatOS Documentation
:doctitle: FhatOS: A Distributed Operating System for Embedded Systems

= FhatOS: A Distributed Operating System for Embedded Systems (v{revnumber})

++++
<script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css"/>
++++

image:fhatos-logo.png[width=140,float=left] **FhatOS** (pronounced _fat-ahs_) is a
https://en.wikipedia.org/wiki/Distributed_operating_system[distributed operating system] for
https://en.wikipedia.org/wiki/ESP8266[ESP8266], https://en.wikipedia.org/wiki/ESP32[ESP32],
https://en.wikipedia.org/wiki/Raspberry_Pi[Raspberry PI], and similar fabrications.
Moreover, sandboxed deployments on Linux and MacOSX systems offer the cluster large memory/storage space and processor speed.
All FhatOS resources, from individual datum, complex data structures, files, and threads exist within a single
https://en.wikipedia.org/wiki/Uniform_Resource_Identifier[URI] address space called **furi**
(pronounced "fury" or "fhat URI") -- a subset of the common URI space.
Programs are written in http://mmadt.org[mm-ADT] or https://en.wikipedia.org/wiki/C_(programming_language)[C] / https://en.wikipedia.org/wiki/C%2B%2B[C++]
and communicate with one another via storage structures that maintain subsets of the fURI space.
In general, FhatOS provides a convenient medium for coordinating a heterogeneous collection of hardware processors and their peripheries.

https://github.com/phaseshift-studio/fhatos[üêô **source code**]

== FhatOS Features

. A hardware-agnostic https://en.wikipedia.org/wiki/Scheduling_(computing)[scheduler] for executing multi-threaded https://en.wikipedia.org/wiki/Monoid_(category_theory)[monoids].
. A memory architecture enabling the integration of various storage mediums within a single https://en.wikipedia.org/wiki/Uniform_Resource_Identifier[URI] https://en.wikipedia.org/wiki/Tuple_space[address space].
. A https://en.wikipedia.org/wiki/Clustered_file_system[distributed file] system embedded in the URI address space.
. A programming language for https://en.wikipedia.org/wiki/Fluent_interface[fluently] creating https://en.wikipedia.org/wiki/Monoid[monoids] to control a distributed swarm of https://en.wikipedia.org/wiki/Monad_(functional_programming)[monads].
. A https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop[REPL] environment for writing and deploying monoids in real-time.
. A collection common embedded systems protocols https://en.wikipedia.org/wiki/General-purpose_input/output[GPIO], https://en.wikipedia.org/wiki/Pulse-width_modulation[PWM], https://en.wikipedia.org/wiki/I%C2%B2C[I2C], and https://en.wikipedia.org/wiki/Serial_Peripheral_Interface[SPI].
. A suite of common sensor, actuator, and UI modules.
. A https://en.wikipedia.org/wiki/Sandbox_(computer_security)[sandboxed] distribution enabling Linux and MacOS systems to participate in the cluster.
. A monoidal https://en.wikipedia.org/wiki/Bootloader[bootloader] with support for https://en.wikipedia.org/wiki/Over-the-air_update[OTA] firmware updates.

== FhatOS Boot Loader

The following output is from a Linux boot of FhatOS.
The purpose of this documentation is to explain the mechanics of the boot process and beyond.

[source,bash]
----
$ fhatos --boot:config=../conf/boot-loader.obj
----

++++
<!-- üêñ ./boot_runner.out -->
++++

[source,mmadt,subs="-replacements"]
----
            PhaseShift Studio Presents 
 <`--'>____  ______ __  __  ______  ______  ______  ______ 
 /. .  `'  \/\  ___/\ \_\ \/\  __ \/\__  _\/\  __ \/\  ___\ 
(`')  ,     @ \  __\ \  __ \ \  __ \/_/\ \/\ \ \_\ \ \___  \ 
 `-._,     / \ \_\  \ \_\ \_\ \_\ \_\ \ \_\ \ \_____\/\_____\ 
    )-)_/-(>  \/_/   \/_/\/_/\/_/\/_/  \/_/  \/_____/\/_____/ 
                                   A Dogturd Stynx Production 
    fhatos-0.1-alpha > linux-6.8.0-54-generic > x86_64
       [x86_64]
      Use noobj for noobj
      .oO loading system objs Oo.
[INFO]  [/sys/scheduler] scheduler started
[INFO]  [/sys/router] router started
[INFO]  [/sys/router] main memory [total=>6656]
[INFO]  [/sys/router] heap <none> spanning /sys/# attached
[INFO]  [/sys/router] heap <none> spanning /mnt/# attached
[INFO]  [/sys/router] heap /mnt/boot spanning /boot/# attached
[INFO]  [/sys/router] ../../../conf/boot_config.obj boot config file loaded (size: 746 bytes)
[WARN]  [/sys/router] router has no auto-prefix configuration: noobj
[INFO]  [/sys/router] 
  [
    router=>[resolve=>[namespace=>[:=>/mmadt/,fos:=>/fos/],auto_prefix=>[,/mmadt/,/fos/,/fos/sys/,/fos/io/,/fos/sensor/,/fos/ui/,/fos/util/,/sys/],query=>[write=>[lock=>to_do]],default_config=>[query=>[write=>[sub=>noobj]]]]]
    scheduler=>[def_stack_size=>8096]
    mqtt=>[broker=>mqtt://chibi.local:1883,client=>fhatos_client,cache=>true]
    wifi=>[ssid=>Rodkins-2G,password=>'puppymama',mdns=>fhatos]
    ota=>[host=>mdns://fhatos_client:3232]
    console=>[terminal=>[stdout=>/io/terminal/:stdout,stdin=>/io/terminal/:stdin],nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288]
    fs=>[root=>./data/fs]
  ]@/boot/config
[INFO]  [/sys/router] router boot config dropped
[INFO]  [/sys/router] scheduler boot config dropped
[INFO]  [/sys/router] /sys/lib/heap type imported
[INFO]  [/sys/router] /sys/lib/mqtt type imported
[INFO]  [/sys/router] /sys/lib/bus type imported
[INFO]  [/sys/router] heap /mnt/fos spanning /fos/# attached
      .oO loading mmadt lang Oo.
[INFO]  [/sys/router] heap /mnt/mmadt spanning /mmadt/# attached
      .oO loading fos models Oo.
[INFO]  [/sys/router] heap /mnt/io spanning /io/# attached
[INFO]  [/sys/router] /io/terminal obj loaded
[INFO]  [/sys/router] /io/parser obj loaded
[INFO]  [/io/log] switching from boot logger to system logger
[INFO]  [/sys/router] /io/log obj loaded
[INFO]  [/sys/router] log boot config dropped
[INFO]  [/sys/router] heap /mnt/cache spanning +/# attached
[INFO]  [/sys/type] /sys/structure/lib/fs/:create type defined
[INFO]  [/sys/router] /io/lib/fs type imported
[INFO]  [/mnt/disk] /home/killswitch/software/fhatos/build/docs/build/data/fs file system location mounted
[INFO]  [/sys/router] fs /mnt/disk spanning /disk/# attached
[INFO]  [/sys/router] fs boot config dropped
[INFO]  [/mnt/mqtt] /mnt/mqtt mqtt [broker=>mqtt://chibi.local:1883,client=>fhatos_client,cache=>true] connected
[INFO]  [/mnt/mqtt] cache enabled
[INFO]  [/sys/router] mqtt /mnt/mqtt spanning //io/# attached
[INFO]  [/sys/router] mqtt boot config dropped
[INFO]  [/mnt/bus] mapping /bus==>//io
[INFO]  [/sys/router] bus /mnt/bus spanning /bus/# attached
[INFO]  [/io/console] thread spawned: inst()[cpp]
[INFO]  [/sys/router] /io/console obj loaded
[INFO]  [/sys/router] console boot config dropped
----

++++
<!-- üêì -->
++++

=== Booting on Linux/Unix/Mac

=== Booting on ESP32

=== Booting on ESP8266

=== Booting on RaspberryPi

== FhatOS Architecture

====
TIP: The "animal sticker" images used throughout the documentation are of the chickens, ducks, and dogs that have or are currently living on the FhatFarm.
Many of the code examples attempt to highlight their unique, individual personalities. To learn their names, hover on their image.
====

image:cooties.png[width=140,float=left,title=cooties] FhatOS is designed according to the undertsanding that computing is composed of 3 fundamental phenomena: **structure** (space), **process** (time), and **language** (perspective).
The core FhatOS kernel provides the following resources.

. `/sys/scheduler` (**process**): provides all thread, fiber, and coroutine processes compute time on the underlying hardware processor.
. `/sys/router` (**structure**) : maintains the multi-level tuple space used for storing and retrieving `objs` in the fURI address space.
. `/mmadt/` (**language**): exposes parsing, type management, and caching functionality to all mm-ADT programs.

The FhatOS scheduler and router are accessible to the user when their respective fURIs are dereferenced (`*` or `from`).

++++
<!-- üêñ ./main_runner.out
[a => b, /
 b => [c => /
  [d => e]]]
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> [a => b,
         b => [c =>
          [d => e]]]
=>[
==>a=>b
==>b=>[
===>c=>[d=>e]
=>]
=>]
----

++++
<!-- üêì -->
++++

++++
<!-- üêñ ./main_runner.out
*/sys/scheduler
*/sys/router
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> */sys/scheduler
=>[
==>barrier=>noobj
==>process=>[
=>]
==>config=>[
===>def_stack_size=>8096
=>]
=>]@/sys/scheduler
fhatos> */sys/router
=>[
==>structure=>[
===>/sys/#
===>/mnt/#
===>/boot/#
===>/fos/#
===>/mmadt/#
===>/io/#
===>+/#
===>/disk/#
===>//io/#
===>/bus/#
=>]
==>frame=>[rec][_]
==>config=>[
===>resolve=>[namespace=>[:=>/mmadt/,fos:=>/fos/],auto_prefix=>[,/mmadt/,/fos/,/fos/sys/,/fos/io/,/fos/sensor/,/fos/ui/,/fos/util/,/sys/],query=>[write=>[lock=>to_do]],default_config=>[query=>[write=>[sub=>noobj]]]]
=>]
==>query=>[
===>write=>[lock=>lock?obj{?}<=obj{?}()[cpp],sub=>sub?obj{?}<=obj()[cpp]]
=>]
=>]@/sys/router
----

++++
<!-- üêì -->
++++

Likewise, the mmADT language is encoded within the fURI address space. mmADT's encoding is large as it includes all the mmADT types and instructions.
By dereferencing the `/mmadt` root with the wildcard extension `#`, a reflective representation of the mmADT language is accessed.

+++ <details><summary> +++
üîó fURI encoding of the mmADT language
+++ </summary><div> +++

++++
<!-- üêñ ./main_runner.out "*/mmadt/#/" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> */mmadt/#/
=>[
==>/mmadt/apply=>apply?obj{*}<=obj(rhs=>noobj,args=>[=>])[cpp]
==>/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/at=>at?obj{?}<=obj{?}(from(0?var,noobj)[cpp])[cpp]
==>/mmadt/barrier=>barrier?objs{*}<=objs{*}(from(0?barrier_op,_)[cpp])[cpp]
==>/mmadt/bcode=>[bcode][_]
==>/mmadt/bcode/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/block=>block?obj<=obj{?}(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/bool=>[bool][_]
==>/mmadt/bool/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/neg=>neg(from(0?self,_)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/count=>count?int<=objs{*}()[cpp]
==>/mmadt/delay=>delay(from(0?millis,_)[cpp])[cpp]
==>/mmadt/drop=>drop?obj{?}<=obj{?}(from(0?obj,_)[cpp])[cpp]
==>/mmadt/each=>each(from(0?poly,noobj)[cpp])
==>/mmadt/embed=>embed()[cpp]
==>/mmadt/end=>end?noobj{.}<=obj{*}()[cpp]
==>/mmadt/eq=>eq(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/error=>[error][_]
==>/mmadt/explain=>explain()[cpp]
==>/mmadt/frame=>frame?rec<=obj{?}()[cpp]
==>/mmadt/from=>from?obj{?}<=obj{?}(from(0?uri,_)[cpp],from(1?default,noobj)[cpp])[cpp]
==>/mmadt/goto=>goto(from(0?inst_id,noobj)[cpp])[cpp]
==>/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])
==>/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])
==>/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])
==>/mmadt/inst=>[inst][_]
==>/mmadt/inst/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/int=>[int][_]
==>/mmadt/int/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/int/::/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/mod=>mod(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/neg=>neg(from(0?self,_)[cpp])[cpp]
==>/mmadt/int/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/is=>is?obj{?}<=obj(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lock=>lock(user=>_)[cpp]
==>/mmadt/lshift=>lshift()
==>/mmadt/lst=>[lst][_]
==>/mmadt/lst/::/mmadt/each=>each(from(0?lst,_)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/merge=>merge?objs{*}<=lst(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/within=>within(from(0?code,noobj)[cpp])[cpp]
==>/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])
==>/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])
==>/mmadt/map=>map?obj{?}<=obj{?}(from(0?mapping,noobj)[cpp])[cpp]
==>/mmadt/merge=>merge?obj{?}<=obj(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/mod=>mod(from(0?rhs,noobj)[cpp])
==>/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])
==>/mmadt/neg=>neg(from(0?self,_)[cpp])
==>/mmadt/neq=>neq(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/noobj=>[noobj][_]
==>/mmadt/obj=>[obj][_]
==>/mmadt/objs=>[objs][_]
==>/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])
==>/mmadt/print=>print?obj{?}<=obj{?}(from(0?to_print,_)[cpp])[cpp]
==>/mmadt/prod=>prod?obj<=objs{*}()[cpp]
==>/mmadt/real=>[real][_]
==>/mmadt/real/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/real/::/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/neg=>neg(from(0?self,_)[cpp])[cpp]
==>/mmadt/real/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/rec=>[rec][_]
==>/mmadt/rec/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/lshift=>lshift(level=>1)[cpp]
==>/mmadt/rec/::/mmadt/merge=>merge?objs{*}<=rec(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/rshift=>rshift(from(0?prefix,noobj)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/within=>within(from(0?code,noobj)[cpp])[cpp]
==>/mmadt/ref=>ref?obj{?}<=obj{?}(from(0?id,noobj)[cpp],from(1?retain,true)[cpp])[cpp]
==>/mmadt/repeat=>repeat(from(0?code,noobj)[cpp],from(1?until,true)[cpp],from(2?emit,false)[cpp])[cpp]
==>/mmadt/rshift=>rshift()
==>/mmadt/split=>split(from(0?poly,noobj)[cpp])[cpp]
==>/mmadt/start=>start?objs{*}<=noobj{.}(from(0?starts,noobj)[cpp])[cpp]
==>/mmadt/str=>[str][_]
==>/mmadt/str/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/str/::/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/merge=>merge?objs{*}<=str(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/str/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/within=>within(from(0?code,noobj)[cpp])[cpp]
==>/mmadt/sum=>sum?obj<=objs{*}()[cpp]
==>/mmadt/to=>to(from(0?uri,noobj)[cpp],from(1?retain,true)[cpp])[cpp]
==>/mmadt/type=>type?uri<=obj{?}(from(0?obj,_)[cpp])[cpp]
==>/mmadt/uri=>[uri][_]
==>/mmadt/uri/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/lshift=>lshift(level=>1)[cpp]
==>/mmadt/uri/::/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/merge=>merge?objs{*}<=uri(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/within=>within(from(0?code,noobj)[cpp])
=>]
----

++++
<!-- üêì -->
++++

+++ </div></details> +++

All resources off the specified kernel fURIs can be interacted with, but can not be shutdown.
That is, `/sys/# -> noobj` yields an error.
Without these resources, FhatOS will not function propertly.

User resources are typicaly structured as below:

. `/io/`: location of input/output devices such as terminal, files, etc.
. `/home/`: location of all user data and programs.
. `/driver/`: location of all external device drivers.
. `/log/`: location of all log output.
. `/ext/`: location of various mm-ADT extensions.

The following subsections will provide a short overview of the aforementioned resources in reverse order: mm-ADT, router, and then scheduler.

++++
<!-- üêñ ./main_runner.out
*/io/console
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> */io/console
=>console[
==>halt=>false
==>delay=>nat[0]
==>loop=>inst()[cpp]
==>config=>[
===>nest=>2
===>prompt=>'fhatos> '
===>strict=>false
===>log=>INFO
===>stack_size=>24288
=>]
=>]@/io/console
----

++++
<!-- üêì -->
++++


=== The mm-ADT Language

FhatOS software can be written in C/C\++ or mm-ADT (**multi-model abstract data type**). mm-ADT is a reflective, cluster-oriented programming language.
Every expression in mm-ADT yields an `obj` (object).
An `obj` can be any one of

. 5 **mono-types** (`bool`, `int`, `real`, `uri`, and `str`),
. 2 **poly-types** (`lst` and `rec`), or
. 2 **code-types** (`inst` and `bcode`).

The mono and poly types are **structural**, while the code-types are **functional**.

==== Structural Types

The 7 structural types (5 mono-types and 2 poly-types) are described below.

. `/type/bool`: The set of binary values `true` and `false`.
. `/type/int`: The set of (32/64)-bit integers between `-46666666` and `4777777`.
. `/type/real`: The set of (32/64)-bit floating point values between `-...` and `....`.
. `/type/str`: The infinite set of all character sequences.
. `/type/uri`: The infinite set of all fHatOs Uniform Resource Identifiers (fURIs).
. `/type/lst`: An (un)ordered container of zero or more `objs`.
. `/type/rec`: An (un)ordered container of key/value pair `objs`, where keys are unique.

.Controlling Base Value Bit Encoding
====
TIP: The size of `int` and `real` in bits can be specified in the boot loader.
Other machines in the cluster with a different bit-length encoding can still be communicated with.
However, overflow is possible, but can be automatically checked using types in `/mmadt/ext/` such as:
`int8`, `int16`, `int32`.

[cols="5,5"]
|===
a|
++++
<!-- üêñ ./main_runner.out
int[6].inspect()
real[6.0].inspect()
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> int[6].inspect()
=>[
==>type=>[
===>id=>/mmadt/int
===>obj=>[int][_]
===>dom=>[id=>/mmadt/obj,coeff=>[1,1]]
===>rng=>[id=>/mmadt/int,coeff=>[1,1]]
=>]
==>value=>[
===>obj=>6
===>encoding=>int32_t
=>]
=>]
fhatos> real[6.0].inspect()
=>[
==>type=>[
===>id=>/mmadt/real
===>obj=>[real][_]
===>dom=>[id=>/mmadt/obj,coeff=>[1,1]]
===>rng=>[id=>/mmadt/real,coeff=>[1,1]]
=>]
==>value=>[
===>obj=>6.000000
===>encoding=>float_t
=>]
=>]
----

++++
<!-- üêì -->
++++

a|
++++
<!-- üêñ ./main_runner.out
/sys/router/config/resolve/auto_prefix -> *(_).plus(\|[/mmadt/ext/])
a -> int8[126]
@a + 1
@a + 1
@a + 1
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> /sys/router/config/resolve/auto_prefix -> *(_).plus(\|[/mmadt/ext/])
=>[
===>
===>/mmadt/
===>/fos/
===>/fos/sys/
===>/fos/io/
===>/fos/sensor/
===>/fos/ui/
===>/fos/util/
===>/sys/
===>/mmadt/ext/
=>]
fhatos> a -> int8[126]
==>int8[126]
fhatos> @a + 1
==>int8[127]@a
fhatos> @a + 1
==>int8[128]@a
fhatos> @a + 1
[ERROR] [/sys/type] 129@a is not a /fos/int8 as defined by uint8()[is(gte(-127)).is(lte(128))]
	  thrown at inst int8[128]@a => plus(1)[cpp] [code=>'@a + 1',0=>1]
----

++++
<!-- üêì -->
++++
|===
====

. The `inst` `*` dereferences the `/fos/nat` fURI which points to the respective type definition.
. The `/fos/nat` type is applied to a value by wrapping the value in `[]`.
. The router's default `auto-prefix` configuration contains `/fos/#` and thus, the shorthand `nat` can be used.
. If a type wraps a value that doesn't satisfy the type definition, an `error` occurs.

.Base Type Sugar
====
TIP: Given the frequency of use of base types, specifying the type is not necessary as, given the value, the base type can be deduced.

++++
<!-- üêñ ./main_runner.out "/mmadt/int[6]" "int[6]" "6" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> /mmadt/int[6]
==>6
fhatos> int[6]
==>6
fhatos> 6
==>6
----

++++
<!-- üêì -->
++++
====

Examples of the aforementioned types are provided below.

++++
<!-- üêñ ./main_runner.out "true" "42" "-64.02567" "'the fhatty'" "mmadt://a/furi" "[-1,'fhat',[0,1]]" "[a=>1,b=>'2',c=>3.0]" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> true
==>true
fhatos> 42
==>42
fhatos> -64.02567
==>-64.0257
fhatos> 'the fhatty'
==>'the fhatty'
fhatos> mmadt://a/furi
==>mmadt://a/furi
fhatos> [-1,'fhat',[0,1]]
=>[
===>-1
===>'fhat'
=>[
===>0
===>1
=>]
=>]
fhatos> [a=>1,b=>'2',c=>3.0]
=>[
==>a=>1
==>b=>'2'
==>c=>3.000000
=>]
----

++++
<!-- üêì -->
++++

==== Values

===== By Value vs. By Reference

[rows]
|===
a|
[source,mmadt]
----
age[45]@x => plus(10) => age[55]@x
    ^                        ^
   @\|                        \|
    x------------------------/
   *\|
    v
age[45]  =>  plus(10) => age[55]
----
a|

++++
<!-- üêñ ./main_runner.out
age -> \|(is(gt(0)).is(lt(120)))
a -> age[45]
*a.inspect()
@a.inspect()
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> age -> \|(is(gt(0)).is(lt(120)))
==>is?noobj<=obj(gt?noobj<=obj(0)[noobj])[noobj].is?noobj<=obj(lt?noobj<=obj(120)[noobj])[noobj]
fhatos> a -> age[45]
==>age[45]
fhatos> *a.inspect()
[ERROR] [/mmadt/bcode] 45 is not a /mmadt/bcode as defined by [bcode][_]
fhatos> @a.inspect()
[ERROR] [/mmadt/bcode] 45@a is not a /mmadt/bcode as defined by [bcode][_]
----

++++
<!-- üêì -->
++++

|===

++++
<!-- üêñ ./main_runner.out "a?sub -> |print(_)" "a -> 12" "@a.inspect()" "@a.plus(1)" "@a.plus(1).plus(1)" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> a?sub -> |print(_)
==>print?noobj<=obj(_)[noobj]
fhatos> a -> 12
==>12
12fhatos> @a.inspect()
=>[
==>type=>[
===>id=>/mmadt/int
===>obj=>[int][_]
===>dom=>[id=>/mmadt/obj,coeff=>[1,1]]
===>rng=>[id=>/mmadt/int,coeff=>[1,1]]
=>]
==>value=>[
===>id=>a
===>obj=>12@a
===>encoding=>int32_t
=>]
==>sub=>[
===>source=>/sys/scheduler
===>pattern=>a
===>on_recv=>print(_)
=>]
=>]
12@afhatos> @a.plus(1)
==>13@a
13@afhatos> @a.plus(1).plus(1)
==>15@a
----

++++
<!-- üêì -->
++++

==== Expression Structure

[source]
----
obj.f(obj).f(obj).f(obj)
----

===== Bytecode and Instruction Types

===== User Defined Types

image:ginger.png[width=140,float=left]  mm-ADT is a structurally typed language, whereby if an `obj` *A* __matches__ `obj` *B*, then *A* is _a type of_ *B*.
An `obj` type is a simply an mm-ADT program that verifies instances of the type.
For instance, if a natural number stem:[\mathbb{N}] is any non-negative number, then natural numbers are a subset (or refinement) of `int`.

++++
<!-- üêñ ./main_runner.out "/type/int/nat -> |is(gt(0))" "nat[6]" "nat[-6]" "nat[3].plus(2)" "nat[3].mult(-2)" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> /type/int/nat -> |is(gt(0))
[ERROR] [/sys/router] no attached structure for /type/int/nat  
==>is?noobj<=obj(gt?noobj<=obj(0)[noobj])[noobj]
fhatos> nat[6]
==>nat[6]
fhatos> nat[-6]
[ERROR] [/sys/type] -6 is not a /fos/nat as defined by nat()[is(gte(0))]
fhatos> nat[3].plus(2)
==>nat[5]
fhatos> nat[3].mult(-2)
[ERROR] [/sys/type] -6 is not a /fos/nat as defined by nat()[is(gte(0))]
	  thrown at inst nat[3] => mult(-2)[cpp] [code=>'nat[3].mult(-2)',0=>-2]
----

++++
<!-- üêì -->
++++

===== Process Types

A simple mm-ADT program is defined below.
The program is a specialization of the poly-type `rec` called `thread`, where `thread` is abstractly defined as

++++
<!-- ./main_runner.out
threadx[[ /
  halt=>false, /
  delay=>nat[0], /
  loop=>from(|a,0).plus(1).to(a).print(_). /
         [is(gt(10)) => |true.to(abc/halt)]>-]]@abc
@abc.spawn()
-->
++++

The `thread` object is published to the fURI endpoint `esp32@127.0.0.1/scheduler/threads/logger`.
The scheduler spawns the program on an individual `thread` accessible via the target fURI.
Once spawned, the `setup` function prints the thread's id and halts.

=== The Router Structure

image:cooties-2.png[width=140,float=right] Every fhatOS machine has a single _router_.
The function of the router is to:

. Route read/write requests to respective structures.
. Coordinate with remote routers on remote read/write requests.
. Manage pattern conflicts between structures.
. Manage fURI query extensions (`?` modulators).

++++
<!-- üêñ ./main_runner.out "/io/console/config/nest->3" "*/sys/router/#/" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> /io/console/config/nest->3
==>3
fhatos> */sys/router/#/
=>[
==>/sys/router=>[
===>structure=>[
====>/sys/#
====>/mnt/#
====>/boot/#
====>/fos/#
====>/mmadt/#
====>/io/#
====>+/#
====>/disk/#
====>//io/#
====>/bus/#
==>]
===>frame=>[rec][_]
===>config=>[
====>resolve=>[namespace=>[:=>/mmadt/,fos:=>/fos/],auto_prefix=>[,/mmadt/,/fos/,/fos/sys/,/fos/io/,/fos/sensor/,/fos/ui/,/fos/util/,/sys/],query=>[write=>[lock=>to_do]],default_config=>[query=>[write=>[sub=>noobj]]]]
==>]
===>query=>[
====>write=>[lock=>lock?obj{?}<=obj{?}()[cpp],sub=>sub?obj{?}<=obj()[cpp]]
==>]
=>]@/sys/router
=>]
----

++++
<!-- üêì -->
++++

The router manages access to physical memory.
Physical memory is partitioned by *structures*.
The address space of a structure is the (query-less) fURI.
Structures have an associated *pattern* fURI defining the boundaries of their storage space.
Structures can not have overlapping address spaces.
Every structure implements the `structure.hpp` and ultimately, is an `obj`.

- There are structures that encode `objs` in physical memory (e.g. `heap`).
- There are structures that encode `objs` on disk (e.g. `fs` -- filesystem).
- There are structures that encode `objs` on a remote broker (e.g. `mqtt`).
- There are structures that encode `objs` in the Bluetooth hierarchy (e.g. `bt`).
- There are structures that encode `objs` on RFID chips (e.g. `rfid`).
- There are structures that encode `objs` as scoped variables when evaluating code (e.g. `frame`).
- There are structures that encode other structures (e.g. `mnt`).

The aggregate of all structures accessible through the router defines the complete memory footprint of a fHaTOS instance.

++++
<!-- üêñ ./main_runner.out
a -> 'snowbutt'            --- <1>
*a                         --- <2>
a?sub -> |(*payload.to(b)) --- <3>
*a?sub                     --- <4>
a -> 'meangirl'            --- <5>
*b                         --- <6>
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> a -> 'snowbutt'            --- <1>
==>'snowbutt'
fhatos> *a                         --- <2>
==>'snowbutt'
fhatos> a?sub -> |(*payload.to(b)) --- <3>
==>from?noobj<=obj(payload)[noobj].to?noobj<=obj(b)[noobj]
fhatos> *a?sub                     --- <4>
=>sub[
==>source=>/sys/scheduler
==>pattern=>a
==>on_recv=>from(payload).to(b)
=>]
fhatos> a -> 'meangirl'            --- <5>
==>'meangirl'
fhatos> *b                         --- <6>
==>'meangirl'
----

++++
<!-- üêì -->
++++

<1> A request to write `str['snowbutt']` to `uri[a]` is sent to the router.
<2> A request to read the `obj` at `uri[a]` is sent to the router.
<3> A subscription request to receive notifications about `uri[a]` is sent to the router.
<4> A request to read the subscriptions of `uri[a]` is sent to the router.
<5> A request to write `str['meangirl']` to `uri[a]` is sent to the router.
<6> A request to read `uri[b]` is sent to the router.

The above example makes salient the router's role is structure usage.
Not only are read/write requests managed by the router, but also subscriptions and the evaluation of their associated `on_recv`-code.
However, ultimately, the router serves as a simple singleton proxy to the structures it manages.
It's in the structures where the heavily lifting of the memory operations takes place.

==== Reading and Writing Structures

Every structure supports 2 primary operations:

. \$\text{read} : U \rightarrow O\$
. \$\text{write}: (U \times O) \rightarrow \emptyset\$

A read accepts a direct fURI (called an `id`) or a match fURI (called a `pattern`).
Within the category of `id` and `pattern`, there are `node` fURIs and `branch` fURIs.
An example itemization is provided below:

* `id`: an unambiguous fURI that references a single address space in the structure.
** `node`: the address of a specific `obj`.
** `branch`: the root address of a collection of `objs`.
* `pattern`: a fURI containing one or more wildcard characters (`+` or `#`) in it's path.
** `node`: a pattern referencing zero or more `objs`.
** `branch`: a pattern referencing zero or more collections of `objs`.

[cols="3,5"]
|===
a|
++++
<!-- üêñ ./main_runner.out
a/a -> 1; a/b -> 2; a/b/c -> 3; a/b/d -> 4;
*a/b            --- <1>
*a/b/           --- <2>
*a/+            --- <3>
*a/+/           --- <4>
*a/#            --- <5>
*a/#/           --- <6>
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> a/a -> 1; a/b -> 2; a/b/c -> 3; a/b/d -> 4;
fhatos> *a/b            --- <1>
==>2
fhatos> *a/b/           --- <2>
=>[
==>a/b/c=>3
==>a/b/d=>4
=>]
fhatos> *a/+            --- <3>
==>1
==>2
fhatos> *a/+/           --- <4>
=>[
==>a/b/c=>3
==>a/b/d=>4
=>]
fhatos> *a/#            --- <5>
==>1
==>2
==>3
==>4
fhatos> *a/#/           --- <6>
=>[
==>a/a=>1
==>a/b=>2
==>a/b/c=>3
==>a/b/d=>4
=>]
----

++++
<!-- üêì -->
++++

a|
====
TIP: The first line in the example appears to be 4 https://en.wikipedia.org/wiki/Pascal_(programming_language)#Semicolons_as_statement_separators[individual statements].
In fact, it is a single fluent expression. The signature of the `end` `inst` (sugar'd `;`) is `end?obj{0}\<=obj{*}`.
This barrier step computes all monads up to it before emitting a `noobj` monad.
With `end`, it's possible to write mm-ADT in the classic statement-oriented, imperative-style where semincolons (effectively) separate atomic operations.
====

<1> Dereferencing an `id`-node fURI to access a single `obj`.
<2> Dereferencing an `id`-branch fURI to access a collection of `objs`.
<3> Dereferencing a `pattern`-node fURI to access `objs` at respective nodes.
<4> Dereferencing a `pattern`-branch fURI to access `objs` at respective branches.
|===

===== Structure Modules and fURI Queries

Every fURI can have any number of key/value(s) pairs attached to it via the `?` query encoding scheme defined by the
https://datatracker.ietf.org/doc/html/rfc3986#section-3.4[W3C URI] specification.
Modules can be added to structures enabling different behaviors on read/write given associated, relevant `?` parameters.
Example modules that come preloaded with fHaTOS are:

. `pubsub`: supports asynchronous, event-based access to structure `objs`.
.. `a?sub -> _` (subscribe )
.. `a?sub -> noobj` (unsubscribe)
.. `sub[source=>uri, pattern=>uri, on_recv=>obj]`
.. `msg[target=>uri, payload=>obj, retain=>bool]`
. `lock`: provides resource locking semantics to reading and writing `objs` in a concurrent environment.
.. `a?lock=w` (prevent writes to the `obj` at `a`)
.. `a?lock=rw` (prevent reads and writes to the `obj` at `a`)
.. `a?lock=false` (unlock the `obj` at `a`)
. `type`: provides an `obj` type system encoded within an `obj's` type fURI.
.. `nat?dom=int&dc=1,1&rng=int&rc=1,1` (the `inst` signature of `nat?int<=int()[...]`)

Other modules can be created and deployed across a fHaTOS cluster.

.Query Free fURIs
****
IMPORTANT: The address space of a structures does not include the query parameters.
Query parameters are used by structures to modulate the semantics of a read/write operation and are never used as the address of an `obj`.
However, nothing prevents the `obj` at an address to be a `uri[]` with a query.
Be sure to use the non-sugar'd `< >` fURI syntax when multiple values are associated with a key as the value separating
`,` will be preferentially parsed as a `lst`, `rec`, or `inst` argument separator.
++++
<!-- üêñ ./main_runner.out
abc?k1=v1&k2=v2&k3=v3                     --- <1>
abc?k1=v1,v2&k2=v3&k3=v4,v5,v6            --- <2>
<abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>          --- <3>
<abc?k1=v1,v2&k2=v3&k3=v4,v5,v6> -> 12    --- <4>
*abc
abc -> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>   --- <5>
*abc
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> abc?k1=v1&k2=v2&k3=v3                     --- <1>
==>abc?k1=v1&k2=v2&k3=v3
fhatos> abc?k1=v1,v2&k2=v3&k3=v4,v5,v6            --- <2>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>          --- <3>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6> -> 12    --- <4>
==>12
fhatos> *abc
==>12
fhatos> abc -> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>   --- <5>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> *abc
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
----

++++
<!-- üêì -->
++++

<1> Sugar'd `uri` syntax can be used when no commas are present in the fURI.
<2> Multiple values are deliminated using commas.
<3> To ensure proper parsing, multi-value query `uris[]` should be wrapped in `< >` brackets.
<4> The query of a fURI is stripped when used as a structure address.
<5> The query of a fURI is not stripped when used as a value at a struture address.

****

[source,mmadt]
----
1.plus(2)
----

[cols="7,8"]
|===
a|
++++
<!-- üêñ ./main_runner.out
*a
*b
b -> 12
a -> b
*a
**a
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> *a
fhatos> *b
fhatos> b -> 12
==>12
fhatos> a -> b
==>b
fhatos> *a
==>b
fhatos> **a
==>12
----

++++
<!-- üêì -->
++++

a|
[source,mmadt]
----
   [‚ñ†]                         [‚ñ†]
  /   \                       /   \
 /     \                     /     \
[‚ñ†]    [‚ñ†]                  [‚ñ†]    [‚ñ†]
      /   \                       /   \
     /     \                     /     \
   [‚ñ†]     [b]@x ------------> [12]@b  [‚ñ†]
----
`b` references `12`. `a` references `b`. a double dereferences jumps the monad from `a` to `b` to `12`.
a|
++++
<!-- üêñ ./main_runner.out
a -> 12
*a.plus(10)
*a
@a
@a.plus(10)
*a
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> a -> 12
==>12
fhatos> *a.plus(10)
==>22
fhatos> *a
==>12
fhatos> @a
==>12@a
fhatos> @a.plus(10)
==>22@a
fhatos> *a
==>22@a
----

++++
<!-- üêì -->
++++

a|
[source,mmadt]
----
   [‚ñ†]                          [‚ñ†]
  /   \                        /   \
 /     \                      /     \
[‚ñ†]    [‚ñ†]                   [‚ñ†]    [‚ñ†]
      /   \                           \
     /     \         @a.plus(10)       \
   [‚ñ†]     [12]@a ------------------> [22]@a
----
`12` is written to `a`. `10` is added to `a` (*pass by value* `*`). `a` still stores `12`. `10` is added to `a` (**pass by reference** `@`). `a` now stores `22`.
a|
++++
<!-- üêñ ./main_runner.out "a?sub -> \|to(b)" "*a?sub" "*b" "a->12" "*a" "*b" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> a?sub -> \|to(b)
==>to?noobj<=obj(b)[noobj]
fhatos> *a?sub
=>sub[
==>source=>/sys/scheduler
==>pattern=>a
==>on_recv=>to(b)
=>]
fhatos> *b
fhatos> a->12
==>12
fhatos> *a
==>12
fhatos> *b
==>12
----

++++
<!-- üêì -->
++++


[source,mmadt]
----
fhatos> a?sub -> \|to(b)
[INFO]  [/mnt/cache] [/sys/scheduler]=subscribe=>[+/#]
==>to?obj<=obj(b)[noobj]
fhatos> *a?sub
fhatos> *b
fhatos> a->12
==>12
fhatos> *a
==>12
fhatos> *b
==>12

----

a|
[source,mmadt]
----
   [‚ñ†]                          [‚ñ†]
  /   \                        /   \
 /     \                      /     \
[‚ñ†]    [‚ñ†]        [sub]     [‚ñ†]     [‚ñ†]
      /   \      .     .   /   \
     /     \    .       . /     \
   [‚ñ†]     [12]@a       [12]@b  [‚ñ†]
----
subscribes to `a` with bcode of the form \$f(a) -> b\$. `12` is written to `a` which triggers the subscription bcode to write `12` to `b`.
|===

==== Embedding

mm-ADT was designed to support the creation and manipulation of _abstract data types_ -- the "ADT" in mm-ADT.
When expressing abstract data types is natural, then it's possible to leverage _multiple models_ such as key/value, document, relational, vector, graph, and the various nooks and crannies between -- the "mm" in mm-ADT.

mm-ADT's URI addressing scheme makes it possible to _embed_ an array data types into the underlying fHaTOs structure.
This section will explore the following considerations when designing a _multi-model abstract data type_.

. **spatial encodings**
. **schema encodings**
. **language encodings**

===== Spatial Consideration when Embedding

++++
<!-- üêñ ./main_runner.out
1.plus(2)
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> 1.plus(2)
==>3
----

++++
<!-- üêì -->
++++

A _matrix_ is an \$n \times m\$ data structure composed of \$n\$ vectors/row, each with \$m\$ elements/columns.
A relational database _table_ is an example of a matrix, where the entries typically span numeric and non-numeric data types.
There are two general approaches to embedding a matrix or table into an `fstruct`.
Each at opposite ends of the space/time-tradeoff landscape.

[cols="5,5,5"]
|===
a|
[source,mmadt]
----
 \    \|   \|    /
 [‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]

-[‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]-

 [‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]
 /    \|   \|    \
----
a|
[source,mmadt]
----
m/0-[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]


m/1-[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]


m/2-[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
----

a|
[source,mmadt]
----
   0-[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
  /
 /
m--1-[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
 \
  \
   2-[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]


----
a|
++++
<!-- üêñ ./main_runner.out
m/0/0 -> 0
m/0/1 -> 1
m/0/2 -> 2
m/0/3 -> 3
m/1/0 -> 4
m/1/1 -> 5
m/1/2 -> 6
m/1/3 -> 7
m/2/0 -> 8
m/2/1 -> 9
m/2/2 -> 10
m/2/3 -> 11
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> m/0/0 -> 0
==>0
fhatos> m/0/1 -> 1
==>1
fhatos> m/0/2 -> 2
==>2
fhatos> m/0/3 -> 3
==>3
fhatos> m/1/0 -> 4
==>4
fhatos> m/1/1 -> 5
==>5
fhatos> m/1/2 -> 6
==>6
fhatos> m/1/3 -> 7
==>7
fhatos> m/2/0 -> 8
==>8
fhatos> m/2/1 -> 9
==>9
fhatos> m/2/2 -> 10
==>10
fhatos> m/2/3 -> 11
==>11
----

++++
<!-- üêì -->
++++


a|
++++
<!-- üêñ ./main_runner.out
m/0 -> [0,1,2,3]
m/1 -> [4,5,6,7]
m/2 -> [8,9,10,11]
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> m/0 -> [0,1,2,3]
=>[
===>0
===>1
===>2
===>3
=>]
fhatos> m/1 -> [4,5,6,7]
=>[
===>4
===>5
===>6
===>7
=>]
fhatos> m/2 -> [8,9,10,11]
=>[
===>8
===>9
===>10
===>11
=>]
----

++++
<!-- üêì -->
++++

a|
++++
<!-- üêñ ./main_runner.out
m -> [<0>=>[0,1,2,3], /
      <1>=>[4,5,6,7], /
      <2>=>[8,9,10,11]]
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> m -> [<0>=>[0,1,2,3],
              <1>=>[4,5,6,7],
              <2>=>[8,9,10,11]]
=>[
==>0=>[
===>0
===>1
===>2
===>3
=>]
==>1=>[
===>4
===>5
===>6
===>7
=>]
==>2=>[
===>8
===>9
===>10
===>11
=>]
=>]
----

++++
<!-- üêì -->
++++

|===

[source,mmadt]
----
                                    [a=>[b,c]]
                                       [‚ñ†]
          [‚ñ†]                         /   \
                              [b=>c][‚ñ†]   [‚ñ†][d=>e]

   [a=>[b=>c,d=>e]]]            [a=>[b=>c,d=>e]]]
           ^                            ^
           |                            |
           x                            x/

----

=== The Scheduler Process

=== A FhatOS Console

.FhatOS Console
****
The FhatOS Console is a composite of 3 other actors:

. The `Terminal` (`/sys/io/terminal/`) provides thread-safe access to hardware I/O.
. The `Parser` (`/sys/lang/parser/`) converts string input to bytecode output.
. The `Processor` (`/sys/lang/processor/`) executes bytecode.
****

=== fURI and MQTT

https://en.wikipedia.org/wiki/MQTT[MQTT] is a publish/subscribe message passing protocol that has found extensive usage in embedded systems.
Hierarchically specified _topics_ can be **subscribed** and **published** to.
In MQTT, there is no direct communication between actors, though such behavior can be simulated if an actor's mailbox is a unique topic.
FhatOS leverages MQTT, but from the vantage point of URIs instead of topics with message routing being location-aware.
There exist three MQTT routers:

. `MonadRouter`: An MQTT router scoped to an active monad (**thread**) processing a monoid (**program**).
. `MonoidRouter`: An MQTT router scoped to a monoid (**program**).
. `HostRouter`: An MQTT router scoped to the current host (**machine**).
. `ClusterRouter`: An MQTT router scoped to the current intranet (**cluster**).
. `GlobalRouter` : An MQTT router scoped to the Internet.
. `MetaRouter`: An MQTT router dynamically scoped to other routers based on fURI endpoints.

.fURI Router Scope Patterns
****
TIP: The more `/` in the fURI prefix, the more distributed the fURI repeat.
* `abc` monad scoped fURI.
* `~/abc` monoid scoped fURI ("home directory" of executing program).
* `/abc` host scoped fURI (rooted at `localhost`).
* `//abc` cluster scoped fURI (hosted on the intranet).
* `//fhatos.org/abc` globally scoped fURI (hosted on the internet)
****

.Monoid power method
[latexmath]
++++
M = aM
++++

++++
<!-- üêñ ./main_runner.out
{1,2,3}
{1,2,3}.plus(10)
{1,2,3}.plus(_)
{1,2,3}.plus(plus(_))
-->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> {1,2,3}
==>1
==>2
==>3
fhatos> {1,2,3}.plus(10)
==>11
==>12
==>13
fhatos> {1,2,3}.plus(_)
==>2
==>4
==>6
fhatos> {1,2,3}.plus(plus(_))
==>3
==>6
==>9
----

++++
<!-- üêì -->
++++

== FhatOS Modules

=== Kernel Modules

==== mmADT Module (mmadt)

===== Type Module (mmadt:type)

===== Parser Module (mmadt:parser)

==== Scheduler Module (scheduler)

==== Router Module (router)

=== Core Modules

==== Pin Modules

===== GPIO (gpio)

Hardware devices with digital general purpose input/output (GPIO) can be manipulated with `/fos/io/gpio`.

===== PWM (pwm)

Pins that support pulse-wave modulation can be manipulated with `/fos/io/pwm`.

===== i2c (i2c)

Two wire acess

==== FileSystem Module (fs)

==== Terminal Module (terminal)

==== REPL Module (repl)

==== Logging Module (log)

=== Embedded Systems Modules

==== Sensors

==== Actuators

== Reference

=== mm-ADT Core Instructions

==== as `[_]`

==== block `|`

==== is

==== plus

++++
<!-- üêñ ./main_runner.out "true.plus(false)" "1.plus(2)" "'a'.plus('b')" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> true.plus(false)
==>true
fhatos> 1.plus(2)
==>3
fhatos> 'a'.plus('b')
==>'ab'
----

++++
<!-- üêì -->
++++

==== mult

==== mod

==== lift `^`

==== drop `v`

==== split `-<`

==== each `=`

==== within `\_/ \_`

==== merge `>-`

==== from `*`

==== to `\->`

==== get `@`

==== pass `-\->`

==== match `~`

++++
<!-- üêñ ./main_runner.out "[a=>2].match([a=>3])" "[a=>2].match([a=>_])" -->
++++

[source,mmadt,subs="-replacements"]
----
fhatos> [a=>2].match([a=>3])
[ERROR] [/mmadt/rec] match inst unresolved 
	         lhs id      inst id    resolve obj
	  ->[/mmadt/rec] match => noobj
	 -->[/mmadt/rec] match => noobj
	--->[          ] match => noobj
fhatos> [a=>2].match([a=>_])
[ERROR] [/mmadt/rec] match inst unresolved 
	         lhs id      inst id    resolve obj
	  ->[/mmadt/rec] match => noobj
	 -->[/mmadt/rec] match => noobj
	--->[          ] match => noobj
----

++++
<!-- üêì -->
++++

==== eq

==== neq

==== gt

==== lt

==== gte

==== lte

== FhatOS Types

=== Process Types

==== thread

==== fiber

==== coroutine

=== PubSub Types

==== sub

[source,mmadt]
----
sub[[:source=>_, :pattern=>_, :on_recv=>bcode[_]]]
----

==== msg

[source,mmadt]
----
msg[[:target=>uri[_], :payload=>_, :retain=>bool[_]]]
----

=== A Standard fHaTOS Boot Config
  * common router prefixes
  * console w/ terminal spawned
  * mqtt-backed distributed shared memory mounted
  ** furi read/write resolution across cluster
  ---
  * on esp32:
  ** wifi config and connect
  ** mdns config and connect
  ** gpio pin ?q:default mounted
  * on native:
  ** local file system mounted
===
[
 ------------------------------- BOOT GLOBAL VARIABLES -------------------------------
 params => [
   host => f,
   --- esp32 only (native platforms must provide network connectivity)
   wifi => [ssid=><Rodkins-2G>,
            password=>'puppymama',
            mnds=>*/sys/info/platform],
   --- all platforms
   mqtt => [broker=><mqtt://192.168.10.126:1883>],
   net  => [mdns=>/fos/net/inet/mdns()]],
 ---------------------------------- KERNEL BOOT OBJS ----------------------------------
 boot     =>[drop  =>true],
 info     =>[host  =>*/boot/config/params/host]@/sys/info, --- add pairs as needed
 scheduler=>[config=>[def_stack_size=>32768]]@/sys/scheduler,
 router   =>[config=>[auto_prefix=>[<>,/mmadt/ext/,/mmadt/,/sys/,/io/,/fos/s/,/fos/sys/]]]@/sys/router,
 typer    =>[config=>[register=>[/mmadt/#,/fos/#],
                      import=>[/mmadt/#,/fos/#]]]@/sys/typer,
 ----------------------------------- USER BOOT SETUP -----------------------------------
 setup=>setup?obj{?}<=obj{.}()[
    */sys/info.[_=>_];
    /boot/config/name -> <{{*</boot/config/params/host>}}{{*</sys/info/platform>}}>;
    heap[[pattern=><+/#>]]@/mnt/var;
    router::mount(@/mnt/var);
    *</sys/info/platform>-<
      [is(eq(esp32))=>{  --- esp specific
        print('\t!g!_esp32 !y!_specific boot!!\n');
        typer::import(/fos/net/#);
        /fos/net/wifi[[config=>[
            ssid=>*/boot/config/params/wifi/ssid,
            password=>*/boot/config/params/wifi/password,
            mdns=>*/boot/config/name,
            on_connect=>^(print('!gwifi connected!!\n'))
        ]]]@/io/wifi;
        */io/wifi.connect();
        typer::import(/fos/io/gpio);
        /io/gpio/+?q:default -> |[read => ^(<<(2).as(int).as(/fos/io/gpio).read())];
       },
       is(eq(native))=>{ --- native specific
        print('\t!g!_native !y!_specific boot!!\n');
        /sys/router/memory -> |/fos/sys/memory[[=>]];
        /sys/router/memory/main?q:default -> |[read => ^(*/sys/router/memory.main())];
        fs[[pattern=>/fs/#,config=>[root=><.>]]]@/mnt/fs;
        router::mount(@/mnt/fs);
       }]>-;
    print('\t!g!_cluster !y!_specific boot!!\n');
    /boot/config/mdns -> *</sys/info/platform>-<
                            [is(eq(esp32))=>*/io/wifi/config/mdns,
                             is(eq(native))=>*/boot/config/params/net/mdns]>-;
    dsm[[pattern=>//+/#, config=>[broker=>*/boot/config/params/mqtt/broker,
                                  client=>*/boot/config/name,
                                  async=>true,
                                  cache_size=>10]]]@/mnt/cluster;
    router::mount(@/mnt/cluster);
    *</boot/config/name>.<//{{_}}> -> *|/sys/info;
    --- [input,output]>-.-<[<//{{*/boot/config/mdns}}/{{_}}>]>-.ref('remote i/o')
    --- *</boot/config/name>.<//{{_}}/output?q:sub> -> ^(*/io/console.output(*|payload));
    --- total hack for one eval. should be: /io/terminal/netio?q:sub -> ^(*/io/console.output(*|payload));
    *</boot/config/name>.<//{{_}}/input?q:sub> -> ^(/sys/scheduler::eval(*payload,<{{*(target).<<(1)}}/output>));
    *</sys/info/platform>-<[is(eq(native))=>{
      /fos/ui/terminal[[=>]]@/io/terminal;
      /fos/ui/console[[=>]]@/io/console;
      /io/console/config/stack_size -> 16384;
      scheduler::spawn(@/io/console);
    }]>-;
 ]]@/boot/config
:imagesdir: ./images
:favicon: {imagesdir}/fhatos-logo-small.png
:copyright: PhaseShift Studio
:author: üí© Dogturd Stynx
:email: dogturd.stynx@fhatos.org
:revnumber: 0.1
:tabsize: 2
:icons: font
:icon-set: fas
:stem: latexmath
:source-highlighter: highlight.js
:highlightjsdir: ./highlight
:highlightjs-languages: mmadt, bash
:stylesheet: ./css/fhatos.css
:data-uri:
:toc-title: üêñ FhatOS
:toc: left
:toclevels: 4
:license-url: https://www.gnu.org/licenses/agpl-3.0.html
:license-title: AGPLv3
:lang: en
:docinfo: shared
:max-width: 75%
:app-name: FhatOS
:version-label: 0.1-alpha
:docname: FhatOS Documentation
:doctitle: FhatOS: A Distributed Operating System for Embedded Systems

= FhatOS: A Distributed Operating System for Embedded Systems (v{revnumber})

++++
<script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css"/>
++++

image:fhatos-logo.png[width=140,float=left] **FhatOS** (pronounced _fat-ahs_) is a
https://en.wikipedia.org/wiki/Distributed_operating_system[distributed operating system] for
https://en.wikipedia.org/wiki/ESP8266[ESP8266], https://en.wikipedia.org/wiki/ESP32[ESP32],
https://en.wikipedia.org/wiki/Raspberry_Pi[Raspberry PI], and similar fabrications.
Moreover, sandboxed deployments on Linux and MacOSX systems offer the cluster large memory/storage space and processor speed.
All [blue]*f*‚Äã[red]#H#‚Äã[lime]*A*‚Äã[yellow]#T#‚Äã[aqua]#O#‚Äã[fuchsia]#S#‚Äã resources, from individual datum, complex data structures, files, and threads exist within a single
https://en.wikipedia.org/wiki/Uniform_Resource_Identifier[URI] address space called **furi**
(pronounced "fury" or "fhat URI") -- a subset of the common URI space.
Programs are written in http://mmadt.org[mm-ADT] or https://en.wikipedia.org/wiki/C_(programming_language)[C] / https://en.wikipedia.org/wiki/C%2B%2B[C++]
and communicate with one another via storage structures that maintain subsets of the fURI space.
In general, [red]*f*‚Äã[lime]#H#‚Äã[fuchsia]#A#‚Äã[blue]#T#‚Äã[yellow]*O*‚Äã[aqua]#S#‚Äã provides a convenient medium for coordinating a heterogeneous collection of hardware processors and their peripheries.

https://github.com/phaseshift-studio/fhatos[üêô **source code**]

== FhatOS Features

. A hardware-agnostic https://en.wikipedia.org/wiki/Scheduling_(computing)[scheduler] for executing multi-threaded https://en.wikipedia.org/wiki/Monoid_(category_theory)[monoids].
. A memory architecture enabling the integration of various storage mediums within a single https://en.wikipedia.org/wiki/Uniform_Resource_Identifier[URI] https://en.wikipedia.org/wiki/Tuple_space[address space].
. A https://en.wikipedia.org/wiki/Clustered_file_system[distributed file] system embedded in the URI address space.
. A programming language for https://en.wikipedia.org/wiki/Fluent_interface[fluently] creating https://en.wikipedia.org/wiki/Monoid[monoids] to control a distributed swarm of https://en.wikipedia.org/wiki/Monad_(functional_programming)[monads].
. A https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop[REPL] environment for writing and deploying monoids in real-time.
. A collection common embedded systems protocols https://en.wikipedia.org/wiki/General-purpose_input/output[GPIO], https://en.wikipedia.org/wiki/Pulse-width_modulation[PWM], https://en.wikipedia.org/wiki/I%C2%B2C[I2C], and https://en.wikipedia.org/wiki/Serial_Peripheral_Interface[SPI].
. A suite of common sensor, actuator, and UI modules.
. A https://en.wikipedia.org/wiki/Sandbox_(computer_security)[sandboxed] distribution enabling Linux and MacOS systems to participate in the cluster.
. A monoidal https://en.wikipedia.org/wiki/Bootloader[bootloader] with support for https://en.wikipedia.org/wiki/Over-the-air_update[OTA] firmware updates.

== FhatOS Boot Loader

The following output is from a Linux boot of [red]#F#‚Äã[lime]*H*‚Äã[fuchsia]#A#‚Äã[yellow]*t*‚Äã[aqua]#O#‚Äã[blue]#S#‚Äã.
The purpose of this documentation is to explain the mechanics of the boot process and beyond.

[source,bash]
----
$ fhatos --boot:config=../conf/boot-loader.obj
----

++++
<!-- üêñ ./boot_runner.out -->
++++

[source,mmadt]
----
            PhaseShift Studio Presents 
 <`--'>____  ______ __  __  ______  ______  ______  ______ 
 /. .  `'  \/\  ___/\ \_\ \/\  __ \/\__  _\/\  __ \/\  ___\ 
(`')  ,     @ \  __\ \  __ \ \  __ \/_/\ \/\ \ \_\ \ \___  \ 
 `-._,     / \ \_\  \ \_\ \_\ \_\ \_\ \ \_\ \ \_____\/\_____\ 
    )-)_/-(>  \/_/   \/_/\/_/\/_/\/_/  \/_/  \/_____/\/_____/ 
                                   A Dogturd Stynx Production 
    fhatos-0.1-alpha > linux-6.8.0-54-generic > x86_64
       [x86_64]
      Use noobj for noobj
      .oO loading system objs Oo.
[INFO]  [/sys/scheduler] scheduler started
[INFO]  [/sys/router] router started
[INFO]  [/sys/router] main memory [total=>7168]
[INFO]  [/sys/router] heap <none> spanning /sys/# mounted
[INFO]  [/sys/router] heap <none> spanning /mnt/# mounted
[INFO]  [/sys/router] heap /mnt/boot spanning /boot/# mounted
[INFO]  [/sys/router] ../../../conf/boot_config.obj boot config file loaded (size: 795 bytes)
[INFO]  [/sys/router] 
  [
    router=>[resolve=>[namespace=>[:=>/mmadt/,fos:=>/fos/],auto_prefix=>[,/mmadt/,/mmadt/ext/,/fos/,/fos/sys/,/fos/io/,/fos/sensor/,/fos/ui/,/fos/util/,/sys/],query=>[write=>[lock=>to_do]],default_config=>[query=>[write=>[sub=>noobj]]]]]
    scheduler=>[def_stack_size=>8096]
    mqtt=>[broker=>mqtt://chibi.local:1883,client=>fhatos_client,cache=>true,max_size=>50]
    wifi=>[ssid=>Rodkins-2G,password=>'puppymama',mdns=>fhatos]
    ota=>[host=>mdns://fhatos_client:3232]
    console=>[terminal=>[stdout=>/io/terminal/:stdout,stdin=>/io/terminal/:stdin],nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]
    fs=>[root=>./data/fs]
  ]@/boot/config
[INFO]  [/sys/router] router boot config dropped
[INFO]  [/sys/router] scheduler boot config dropped
[INFO]  [/sys/router] /sys/lib/heap type imported
[INFO]  [/sys/router] /sys/lib/dsm type imported
[INFO]  [/sys/router] /sys/lib/bus type imported
[INFO]  [/sys/router] heap /mnt/fos spanning /fos/# mounted
      .oO loading mmadt lang Oo.
[INFO]  [/mnt/mmadt] query processor /mnt/mmadt/q/doc attached
[INFO]  [/sys/router] heap /mnt/mmadt spanning /mmadt/# mounted
      .oO loading fos models Oo.
[INFO]  [/sys/router] heap /mnt/io spanning /io/# mounted
[INFO]  [/sys/router] /io/parser obj loaded
[INFO]  [/io/log] switching from boot logger to system logger
[INFO]  [/sys/router] /io/log obj loaded
[INFO]  [/sys/router] log boot config dropped
[INFO]  [/sys/router] heap /mnt/cache spanning +/# mounted
[INFO]  [/sys/type] /sys/structure/lib/fs/:create type defined
[INFO]  [/sys/router] /io/lib/fs type imported
[INFO]  [/mnt/disk] /home/killswitch/software/fhatos/build/docs/build/data/fs file system location mounted
[INFO]  [/sys/router] fs /mnt/disk spanning /disk/# mounted
[INFO]  [/sys/router] fs boot config dropped
[INFO]  [/mnt/dsm] query processor /mnt/dsm/ attached
[INFO]  [/mmadt/rec] mqtt://chibi.local:1883 mqtt fhatos_client connected
[INFO]  [/sys/router] dsm /mnt/dsm spanning /shared/# mounted
[INFO]  [/sys/router] mqtt boot config dropped
[INFO]  [/mnt/bus] mapping /bus==>//io
[INFO]  [/sys/router] bus /mnt/bus spanning /bus/# mounted
[INFO]  [/sys/router] /io/console obj loaded
[INFO]  [/io/console] thread spawned: inst()[cpp]
[INFO]  [/sys/router] console boot config dropped
----

++++
<!-- üêì -->
++++

=== Booting on Linux/Unix/Mac

=== Booting on ESP32

=== Booting on ESP8266

=== Booting on RaspberryPi

== FhatOS Architecture

====
TIP: The "animal sticker" images used throughout the documentation are of the chickens, ducks, dogs and cats that have or are currently living on the FhatFarm.
To learn their names, hover on their image.
====

image:cooties.png[width=140,float=left,title=cooties] [yellow]*f*‚Äã[red]*h*‚Äã[fuchsia]#a#‚Äã[aqua]#t#‚Äã[blue]*O*‚Äã[lime]*S*‚Äã is designed according to the philosophy that computing is composed of 3 fundamental, interacting phenomena:
[.h]#structure# (space), [.h]#process# (time), and [h.]#language# (perspective).
As such,the [yellow]*f*‚Äã[lime]#H#‚Äã[blue]*a*‚Äã[fuchsia]#t#‚Äã[red]*O*‚Äã[aqua]*S*‚Äã kernel is comprised of the followng resources:

. `/sys/scheduler` (**process**): coordinates all processes realized as https://en.wikipedia.org/wiki/Thread_(computing)[threads], fibers, and coroutines.
. `/sys/router` (**structure**) : manages all structures comprising a distributed, partitioned, read/write https://en.wikipedia.org/wiki/Tuple_space[tuple space].
. `/mmadt/` (**language**): provides https://en.wikipedia.org/wiki/Parsing_expression_grammar[parsing], https://en.wikipedia.org/wiki/Type_system[type reasoning], and execution of mmADT programs.

These resources are accessible via their respective fURIs.
The fURI space is a subset of the common URI space, and is the address space through which all resources within [lime]*f*‚Äã[aqua]*h*‚Äã[fuchsia]#a#‚Äã[red]#t#‚Äã[blue]#o#‚Äã[yellow]#s#‚Äã communicate.
A fURI is https://en.wikipedia.org/wiki/Reference_(computer_science)[dereferenced] using the mmADT `from` instruction (sugar'd `*`).
Dereferencing returns the resources pointed to by the fURI.
In mmADT, these resources are called `obj` (objects).

[tabs]
====
/sys/scheduler::
+
--
The [.h]#scheduler# controls and provides access to the various *processes* that define the [red]*F*‚Äã[lime]*h*‚Äã[blue]*a*‚Äã[yellow]#t#‚Äã[aqua]#o#‚Äã[fuchsia]#s#‚Äã process architecture.
++++
<!-- üêñ ./main_runner.out "*/sys/scheduler" -->
++++

[source,mmadt]
----
fhatos> */sys/scheduler
=>[
==>thread=>[
=>]
==>config=>[
===>def_stack_size=>8096
=>]
==>::=>[
===>spawn=>spawn?obj<=obj{?}(thread=>_)[cpp]
=>]
=>]@/sys/scheduler
----

++++
<!-- üêì -->
++++

--

/sys/router::
+
--
The [.h]#router# is responsible for storing and retrieving `objs` from a pool of *structures* that define the [fuchsia]*F*‚Äã[lime]#H#‚Äã[yellow]*a*‚Äã[red]#T#‚Äã[blue]*O*‚Äã[aqua]#S#‚Äã memory architecture.
++++
<!-- üêñ ./main_runner.out
[HIDDEN] /io/console/config/nest -> 5
*/sys/router
-->
++++

[source,mmadt]
----
fhatos> */sys/router
=>[
==>structure=>[
===>/sys/#
===>/mnt/#
===>/boot/#
===>/fos/#
===>/mmadt/#
===>/io/#
===>+/#
===>/disk/#
===>/shared/#
===>/bus/#
=>]
==>frame=>[rec][_]
==>config=>[
===>resolve=>[
====>namespace=>[
=====>:=>/mmadt/
=====>fos:=>/fos/
===>]
====>auto_prefix=>[
=====>
=====>/mmadt/
=====>/mmadt/ext/
=====>/fos/
=====>/fos/sys/
=====>/fos/io/
=====>/fos/sensor/
=====>/fos/ui/
=====>/fos/util/
=====>/sys/
===>]
====>query=>[
=====>write=>[
======>lock=>to_do
====>]
===>]
====>default_config=>[
=====>query=>[
======>write=>[sub=>noobj]
====>]
===>]
==>]
=>]
==>query=>[
===>write=>[
====>lock=>lock?obj{?}<=obj{?}()[cpp]
====>sub=>sub?obj{?}<=obj()[cpp]
==>]
=>]
=>]@/sys/router
----

++++
<!-- üêì -->
++++
--

/mmadt::
+
--
The [.h]#mmADT# language is embedded in the fURI address space thus enabling https://en.wikipedia.org/wiki/Reflective_programming[reflective] programming.
++++
<!-- üêñ ./main_runner.out "*/mmadt/#/" -->
++++

[source,mmadt]
----
fhatos> */mmadt/#/
=>[
==>/mmadt/a=>a(_)[cpp]
==>/mmadt/apply=>apply?obj{*}<=obj(rhs=>noobj,args=>[=>])[cpp]
==>/mmadt/as=>as(isa(/mmadt/uri))[cpp]
==>/mmadt/at=>at?obj{?}<=obj{?}(isa(/mmadt/uri))[cpp]
==>/mmadt/barrier=>barrier?objs{*}<=objs{*}(_)[cpp]
==>/mmadt/bcode=>[bcode][_]
==>/mmadt/bcode/::/mmadt/inspect=>inspect(isa(/mmadt/bool))[cpp]
==>/mmadt/block=>block?obj<=obj{?}(_)[cpp]
==>/mmadt/bool=>[bool][_]
==>/mmadt/bool/::/mmadt/as=>as(isa(/mmadt/uri))[cpp]
==>/mmadt/bool/::/mmadt/div=>div(isa(/mmadt/bool))[cpp]
==>/mmadt/bool/::/mmadt/inspect=>inspect(isa(/mmadt/bool))[cpp]
==>/mmadt/bool/::/mmadt/minus=>minus(isa(/mmadt/bool))[cpp]
==>/mmadt/bool/::/mmadt/mult=>mult(isa(/mmadt/bool))[cpp]
==>/mmadt/bool/::/mmadt/neg=>neg(isa(/mmadt/bool))[cpp]
==>/mmadt/bool/::/mmadt/plus=>plus(isa(/mmadt/bool))[cpp]
==>/mmadt/chain=>chain(_)[cpp]
==>/mmadt/choose=>choose(_)[cpp]
==>/mmadt/count=>count?int<=objs{*}()[cpp]
==>/mmadt/div=>div(_)
==>/mmadt/drop=>drop?obj{?}<=obj{?}(isa(/mmadt/obj))[cpp]
==>/mmadt/each=>each(isa(/mmadt/obj))
==>/mmadt/embed=>embed()[cpp]
==>/mmadt/end=>end?noobj{.}<=obj{*}()[cpp]
==>/mmadt/eq=>eq(_)[cpp]
==>/mmadt/error=>[error][_]
==>/mmadt/explain=>explain()[cpp]
==>/mmadt/ext/C=>C()[is(gte(-273.149994))]
==>/mmadt/ext/Ox=>Ox()[is(true)]
==>/mmadt/ext/char=>char()[merge(2).count().is(eq(1))]
==>/mmadt/ext/int16=>[int16][_]
==>/mmadt/ext/int32=>[int32][_]
==>/mmadt/ext/int8=>uint8()[is(gte(-127)).is(lte(128))]
==>/mmadt/ext/ms=>[real][_]
==>/mmadt/ext/ms/::/mmadt/as=>as(is(eq(/mmadt/ext/sec)))[cpp]
==>/mmadt/ext/nat=>nat()[is(gte(0))]
==>/mmadt/ext/prnt=>prnt()[is(gte(0.000000)).is(lte(100.000000))]
==>/mmadt/ext/sec=>[real][_]
==>/mmadt/ext/secret=>[str][_]
==>/mmadt/ext/secret/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/ext/uint8=>uint8()[is(gte(0)).is(lte(255))]
==>/mmadt/flip=>flip(_)[cpp]
==>/mmadt/frame=>frame?rec<=obj{?}()[cpp]
==>/mmadt/from=>from?obj{?}<=obj{?}(isa(/mmadt/uri),_)[cpp]
==>/mmadt/gt=>gt(isa(/mmadt/obj))
==>/mmadt/gte=>gte(isa(/mmadt/obj))
==>/mmadt/inspect=>inspect(isa(/mmadt/obj))
==>/mmadt/inst=>[inst][_]
==>/mmadt/inst/::/mmadt/inspect=>inspect(isa(/mmadt/inst))[cpp]
==>/mmadt/int=>[int][_]
==>/mmadt/int/::/mmadt/as=>as(isa(/mmadt/uri))[cpp]
==>/mmadt/int/::/mmadt/div=>div(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/gt=>gt(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/gte=>gte(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/inspect=>inspect(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/lt=>lt(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/lte=>lte(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/minus=>minus(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/mod=>mod(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/mult=>mult(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/neg=>neg(isa(/mmadt/int))[cpp]
==>/mmadt/int/::/mmadt/plus=>plus(isa(/mmadt/int))[cpp]
==>/mmadt/is=>is?obj{?}<=obj(_)[cpp]
==>/mmadt/isa=>isa?obj{?}<=obj(_)[cpp]
==>/mmadt/lift=>lift(_)[cpp]
==>/mmadt/lock=>lock(user=>_)[cpp]
==>/mmadt/lshift=>lshift()
==>/mmadt/lst=>[lst][_]
==>/mmadt/lst/::/mmadt/div=>div(isa(/mmadt/lst))[cpp]
==>/mmadt/lst/::/mmadt/each=>each(isa(/mmadt/lst))[cpp]
==>/mmadt/lst/::/mmadt/inspect=>inspect(isa(/mmadt/lst))[cpp]
==>/mmadt/lst/::/mmadt/merge=>merge?objs{*}<=lst()[cpp]
==>/mmadt/lst/::/mmadt/minus=>minus(isa(/mmadt/lst))[cpp]
==>/mmadt/lst/::/mmadt/mult=>mult(isa(/mmadt/lst))[cpp]
==>/mmadt/lst/::/mmadt/plus=>plus(isa(/mmadt/lst))[cpp]
==>/mmadt/lst/::/mmadt/split=>split(isa(/mmadt/lst))[cpp]
==>/mmadt/lst/::/mmadt/within=>within(_)[cpp]
==>/mmadt/lt=>lt(isa(/mmadt/obj))
==>/mmadt/lte=>lte(isa(/mmadt/obj))
==>/mmadt/map=>map?obj{?}<=obj{?}(_)[cpp]
==>/mmadt/merge=>merge?obj{?}<=obj()[cpp]
==>/mmadt/minus=>minus(_)
==>/mmadt/mod=>mod(from(0?rhs,noobj)[cpp])
==>/mmadt/mult=>mult(_)
==>/mmadt/neg=>neg(isa(/mmadt/obj))
==>/mmadt/neq=>neq(_)[cpp]
==>/mmadt/noobj=>[noobj][_]
==>/mmadt/obj=>[obj][_]
==>/mmadt/objs=>[objs][_]
==>/mmadt/plus=>plus(_)
==>/mmadt/print=>print?obj{?}<=obj{?}(_)[cpp]
==>/mmadt/prod=>prod?obj<=objs{*}()[cpp]
==>/mmadt/real=>[real][_]
==>/mmadt/real/::/mmadt/as=>as(isa(/mmadt/uri))[cpp]
==>/mmadt/real/::/mmadt/div=>div(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/gt=>gt(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/gte=>gte(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/inspect=>inspect(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/lt=>lt(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/lte=>lte(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/minus=>minus(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/mult=>mult(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/neg=>neg(isa(/mmadt/real))[cpp]
==>/mmadt/real/::/mmadt/plus=>plus(isa(/mmadt/real))[cpp]
==>/mmadt/rec=>[rec][_]
==>/mmadt/rec/::/mmadt/div=>div(isa(/mmadt/rec))[cpp]
==>/mmadt/rec/::/mmadt/inspect=>inspect(isa(/mmadt/rec))[cpp]
==>/mmadt/rec/::/mmadt/lshift=>lshift(isa(/mmadt/int))[cpp]
==>/mmadt/rec/::/mmadt/merge=>merge?objs{*}<=rec()[cpp]
==>/mmadt/rec/::/mmadt/minus=>minus(isa(/mmadt/rec))[cpp]
==>/mmadt/rec/::/mmadt/mult=>mult(isa(/mmadt/rec))[cpp]
==>/mmadt/rec/::/mmadt/plus=>plus(isa(/mmadt/rec))[cpp]
==>/mmadt/rec/::/mmadt/rshift=>rshift(isa(/mmadt/uri))[cpp]
==>/mmadt/rec/::/mmadt/within=>within(_)[cpp]
==>/mmadt/ref=>ref?obj{?}<=obj{?}(_,true)[cpp]
==>/mmadt/repeat=>repeat(from(0?code,noobj)[cpp],from(1?until,true)[cpp],from(2?emit,false)[cpp])[cpp]
==>/mmadt/rshift=>rshift()
==>/mmadt/split=>split(_)[cpp]
==>/mmadt/start=>start?objs{*}<=noobj{.}(_)[cpp]
==>/mmadt/str=>[str][_]
==>/mmadt/str/::/mmadt/as=>as(isa(/mmadt/uri))[cpp]
==>/mmadt/str/::/mmadt/div=>div(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/gt=>gt(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/gte=>gte(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/inspect=>inspect(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/lt=>lt(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/lte=>lte(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/merge=>merge?objs{*}<=str()[cpp]
==>/mmadt/str/::/mmadt/minus=>minus(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/mult=>mult(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/plus=>plus(isa(/mmadt/str))[cpp]
==>/mmadt/str/::/mmadt/within=>within(_)[cpp]
==>/mmadt/sum=>sum?obj<=objs{*}()[cpp]
==>/mmadt/to=>to(_,true)[cpp]
==>/mmadt/type=>type?uri<=obj{?}(_)[cpp]
==>/mmadt/uri=>[uri][_]
==>/mmadt/uri/::/mmadt/as=>as(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/div=>div(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/gt=>gt(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/gte=>gte(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/inspect=>inspect(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/lshift=>lshift(isa(/mmadt/int))[cpp]
==>/mmadt/uri/::/mmadt/lt=>lt(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/lte=>lte(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/merge=>merge?objs{*}<=uri()[cpp]
==>/mmadt/uri/::/mmadt/minus=>minus(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/mult=>mult(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/plus=>plus(isa(/mmadt/uri))[cpp]
==>/mmadt/uri/::/mmadt/rshift=>rshift(isa(/mmadt/int))[cpp]
==>/mmadt/within=>within(_)
=>]
----

++++
<!-- üêì -->
++++
--
====

====
IMPORTANT: The `[cpp]` representation of an `inst` value means that the instruction's implementation is written C++.
As such, no further introspection is possible from within mmADT.
When the instruction implementation is written in mmADT, the instruction value is displayed as `bcode` (a linear chain of `objs`).

[cols="2,2"]
|===
a|
An `inst` written in C++.
++++
<!-- üêñ ./main_runner.out "*int::lt" -->
++++

[source,mmadt]
----
fhatos> *int::lt
==>lt?bool<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
----

++++
<!-- üêì -->
++++

a|
An `inst` written in mmADT.
++++
<!-- üêñ ./main_runner.out "*nat" -->
++++

[source,mmadt]
----
fhatos> *nat
==>nat?int<=int()[is(gte(0))]
----

++++
<!-- üêì -->
++++

|===

====

A [yellow]#f#‚Äã[fuchsia]#h#‚Äã[aqua]*A*‚Äã[lime]*T*‚Äã[red]*O*‚Äã[blue]#s#‚Äã instance is shutdown by writing `noobj` (_null_) to every fURI address.

++++
<!-- üêñ ./main_runner.out "# -> noobj" -->
++++

[source,mmadt]
----
fhatos> # -> noobj
[ERROR] [/sys/router] # crosses multiple structures
[INFO]  [/sys/router] 1 bus(s) closing
[INFO]  [/sys/router] 1 dsm(s) closing
[INFO]  [/sys/router] 1 fs(s) closing
[INFO]  [/sys/router] 7 heap(s) closing
[INFO]  [/mmadt/rec] disconnecting from [mqtt://chibi.local:1883]
[INFO]  [/sys/router] router /sys/router stopped
[INFO]  [/sys/router] /sys/# heap detached
[INFO]  [/sys/router] /mnt/# heap detached
[INFO]  [/sys/router] /boot/# heap detached
[INFO]  [/sys/router] /fos/# heap detached
[INFO]  [/sys/router] /mmadt/# heap detached
[INFO]  [/sys/router] /io/# heap detached
[INFO]  [/sys/router] +/# heap detached
[INFO]  [/sys/router] /disk/# fs detached
[INFO]  [/sys/router] /shared/# dsm detached
[INFO]  [/sys/router] /bus/# bus detached
----

++++
<!-- üêì -->
++++

This documentation will explore these three kernel resources in-depth starting with the mmADT language and processor.

=== The mm-ADT Language

mmADT is the programming language of [red]#F#‚Äã[fuchsia]#H#‚Äã[lime]#a#‚Äã[aqua]*T*‚Äã[yellow]*O*‚Äã[blue]#s#‚Äã. In mmADT, every expression is an `obj` (object). The language has an
underlying https://en.wikipedia.org/wiki/Monoid_(category_theory)[monoidal] structure where an `obj` can be applied (`.`) to an `obj` to create an `obj`.

[.center]
[graphviz,diagrams/mmadt-monoid, svg]
----
digraph g {
 size="2.0!";
 bgcolor=transparent
 obj [fontcolor=yellow,color=white];
 obj -> obj [label=obj,fontcolor=fuchsia,color=white];
}
----

An `obj` is composed of a [.h]#type#, a [.h]#value#, a variable [.h]#frame#, and a storage location/[.h]#reference#.
The abstract syntax of a sugar-free `obj` is

[stem]
++++
\tt{obj} := \tt{type}(\tt{frame})[\tt{value}]@\tt{ref}
++++

. The [.h]#type# is a fURI referring to an `obj` which determines whether the `obj` is of that type or not (_predicate_).
. The [.h]#frame# is a collection of fURI referenced `objs` that are accessible to the value of the `obj` (_arguments_).
. The [.h]#value# is a collection of `objs` denoting the form of the `obj` (_encoding_).
. The [.h]#reference# is a fURI denoting the durable location of the `obj` with the underlying storage structure (_memory address_).

The mmADT language and its evaluation by a processor will be explained via an exploration of these substructures, where finer grained structures lie within each.

==== The Type

[stem]
++++
\tt{obj} := \color{yellow}{\underline{\tt{type}}}(\tt{frame})[\tt{value}]@\tt{ref}
++++

There are 9 base types in mmADT. 6 [.h]#mono-types# and 3 [.h]#poly-types#. The mono-types are:

. `/mmadt/noobj`: A singleton representing `null`.
. `/mmadt/bool`: The set of binary values `true` and `false`.
. `/mmadt/int`: The set of \$n\$-bit integers between \$-2^(n-1)\$ and \$2^(n-1)\$.
. `/mmadt/real`: The set of \$n\$-bit floating point values between `-...` and `....`.
. `/mmadt/str`: The infinite set of all UTF-8 character sequences.
. `/mmadt/uri`: The infinite set of all [red]#f#‚Äã[lime]#H#‚Äã[fuchsia]#A#‚Äã[blue]#T#‚Äã[yellow]*o*‚Äã[aqua]#s#‚Äã UTF-8 Uniform Resource Identifiers (fURIs).

The poly-types are:

. `/mmadt/lst`: An (un)ordered collection of zero or more `objs`.
. `/mmadt/rec`: An (un)ordered collection of key/value pair `objs`, where keys are unique.

All other types are defined in terms of these types. Every `obj` has an explicitly declared type.
However, given frequency of base types usage, specifying the type is not necessary it can be deduced from the value.

[tabs]
====
bool::
+
--

++++
<!-- üêñ ./main_runner.out "/mmadt/bool[true]" "bool[true]" "true" -->
++++

[source,mmadt]
----
fhatos> /mmadt/bool[true]
==>true
fhatos> bool[true]
==>true
fhatos> true
==>true
----

++++
<!-- üêì -->
++++
--

int::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/int[6]" "int[6]" "6" -->
++++

[source,mmadt]
----
fhatos> /mmadt/int[6]
==>6
fhatos> int[6]
==>6
fhatos> 6
==>6
----

++++
<!-- üêì -->
++++
--

real::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/real[6.2]" "real[6.2]" "6.2" -->
++++

[source,mmadt]
----
fhatos> /mmadt/real[6.2]
==>6.2
fhatos> real[6.2]
==>6.2
fhatos> 6.2
==>6.2
----

++++
<!-- üêì -->
++++
--

str::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/str['cooties']" "str['cooties']" "'cooties'" -->
++++

[source,mmadt]
----
fhatos> /mmadt/str['cooties']
==>'cooties'
fhatos> str['cooties']
==>'cooties'
fhatos> 'cooties'
==>'cooties'
----

++++
<!-- üêì -->
++++
--

uri::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/uri[/dog/curly]" "uri[/dog/curly]" "/dog/curly" -->
++++

[source,mmadt]
----
fhatos> /mmadt/uri[/dog/curly]
==>/dog/curly
fhatos> uri[/dog/curly]
==>/dog/curly
fhatos> /dog/curly
==>/dog/curly
----

++++
<!-- üêì -->
++++
--

lst::
+
--
++++
<!-- üêñ ./main_runner.out
[HIDDEN] /io/console/config/nest -> 0
/mmadt/lst[['a',2,true]]
lst[['a',2,true]]
['a',2,true]
-->
++++

[source,mmadt]
----
fhatos> /mmadt/lst[['a',2,true]]
==>['a',2,true]
fhatos> lst[['a',2,true]]
==>['a',2,true]
fhatos> ['a',2,true]
==>['a',2,true]
----

++++
<!-- üêì -->
++++
--

rec::
+
--
++++
<!-- üêñ ./main_runner.out
[HIDDEN] /io/console/config/nest->0
/mmadt/rec[[a=>6,b=>false]]
rec[[a=>6,b=>false]]
[a=>6,b=>false]
-->
++++

[source,mmadt]
----
fhatos> /mmadt/rec[[a=>6,b=>false]]
==>[a=>6,b=>false]
fhatos> rec[[a=>6,b=>false]]
==>[a=>6,b=>false]
fhatos> [a=>6,b=>false]
==>[a=>6,b=>false]
----

++++
<!-- üêì -->
++++
--

noobj::
+
--
++++
<!-- üêñ ./main_runner.out
/mmadt/noobj[]
noobj[]

-->
++++

[source,mmadt]
----
fhatos> /mmadt/noobj[]
fhatos> noobj[]
fhatos> 

----

++++
<!-- üêì -->
++++
--
====

When an mmADT `obj` is wrapped in a `type[]`-bracket, the type fURI is first resolved to it's `obj` form (typically as an `inst`) and then the wrapped `obj` is applied to it.
If the result of the application yields an `error` or a `noobj`, then the base value `obj` is not of that type and a type `error` is thrown.
However, should any other `obj` be returned, then the base value `obj` is of that type and is returned wrapped in the respective `type[]`-bracket.

[.center]
[stem]
++++
\[
\begin{align*}
\tt{type}_\tt{furi}[\tt{obj}]          &= \;  \\
\tt{type}_\tt{furi}[\tt{obj}]          &= \; ^*\tt{type}_\tt{furi} \cdot \tt{obj} \\
\tt{type}_\tt{furi}[\tt{obj}]          &= \; \tt{type}_\tt{obj}    \cdot \tt{obj}  \\
\tt{type}_\tt{furi}[\tt{obj}]          &= \; \left\{
  \begin{array}{lr}
        \tt{error}                      & \text{if} \; \tt{type}_\tt{obj}(\tt{obj}) \in \{\tt{error}, \tt{noobj}\} \\
        \tt{type}_\tt{furi}[\tt{obj}]   & \text{otherwise}.
  \end{array}\right\}
\end{align*}
\]
++++

The type can be understood as a https://en.wikipedia.org/wiki/Boolean-valued_function[predicate], where an `error` or `noobj` is `false`, otherwise `true`.
Finally, if the `obj` has a `@`-reference, then any subsequent mutations to that `obj` must continue to satisfy the constraints of the type.
If any mutation falls outside the bounds of the type, a type `error` is thrown.
The `@`-reference ensures that as the referenced `obj` mutates, it's corresponding representation in the underlying fURI structure mutates as well.
This captures the notion of https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference[pass-by-reference] vs. https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value[pass-by-value].

The mechanics of `obj` typing are exemplified below using the generally useful types provided the `/mmadt/ext` prefix.

++++
<!-- üêñ ./main_runner.out "*/mmadt/ext/#/" -->
++++

[source,mmadt]
----
fhatos> */mmadt/ext/#/
=>[
==>/mmadt/ext/C=>C()[is(gte(-273.149994))]
==>/mmadt/ext/Ox=>Ox()[is(true)]
==>/mmadt/ext/char=>char()[merge(2).count().is(eq(1))]
==>/mmadt/ext/int16=>[int16][_]
==>/mmadt/ext/int32=>[int32][_]
==>/mmadt/ext/int8=>uint8()[is(gte(-127)).is(lte(128))]
==>/mmadt/ext/ms=>[real][_]
==>/mmadt/ext/ms/::/mmadt/as=>as(is(eq(/mmadt/ext/sec)))[cpp]
==>/mmadt/ext/nat=>nat()[is(gte(0))]
==>/mmadt/ext/prnt=>prnt()[is(gte(0.000000)).is(lte(100.000000))]
==>/mmadt/ext/sec=>[real][_]
==>/mmadt/ext/secret=>[str][_]
==>/mmadt/ext/secret/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/ext/uint8=>uint8()[is(gte(0)).is(lte(255))]
=>]
----

++++
<!-- üêì -->
++++

[tabs]
====
char::
+
--
A https://en.wikipedia.org/wiki/Character_(computing)[char] is a `str` containing a single character.
++++
<!-- üêñ ./main_runner.out
*char
char['a']@a
char['b']@b
@a + @b
*a
@a.as(str) + @b
-->
++++

[source,mmadt]
----
fhatos> *char
==>char?int<=str()[merge(2).count().is(eq(1))]
fhatos> char['a']@a
==>char['a']@a
fhatos> char['b']@b
==>char['b']@b
fhatos> @a + @b
[ERROR] [/sys/scheduler] [/sys/type] 'aa'@a is not a /mmadt/ext/char as defined by char()[merge(2).count().is(eq(1))]
	  thrown at inst char['a']@a => plus(at(b))[cpp] [0=>char['a']@a]
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'@a + @b')[cpp] [code=>'@a + @b']
fhatos> *a
==>char['a']@a
fhatos> @a.as(str) + @b
==>'aa'@a
----

++++
<!-- üêì -->
++++

--
nat::
+
--
A https://en.wikipedia.org/wiki/Natural_number[natural number] is an element of the set latexmath:[\mathbb{N} = \{0,1,2,\ldots,\infty\}].
++++
<!-- üêñ ./main_runner.out
*nat
nat[12]
nat[-30]
nat[12]@a
@a.minus(11)
@a.minus(2)
*a
-->
++++

[source,mmadt]
----
fhatos> *nat
==>nat?int<=int()[is(gte(0))]
fhatos> nat[12]
==>nat[12]
fhatos> nat[-30]
[ERROR] [/sys/scheduler] [/sys/type] -30 is not a /mmadt/ext/nat as defined by nat()[is(gte(0))]
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'nat[-30]')[cpp] [code=>'nat[-30]']
fhatos> nat[12]@a
==>nat[12]@a
fhatos> @a.minus(11)
==>nat[1]@a
fhatos> @a.minus(2)
[ERROR] [/sys/scheduler] [/sys/type] -1@a is not a /mmadt/ext/nat as defined by nat()[is(gte(0))]
	  thrown at inst nat[1]@a => minus(2)[cpp] [0=>2]
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'@a.minus(2)')[cpp] [code=>'@a.minus(2)']
fhatos> *a
==>nat[1]@a
----

++++
<!-- üêì -->
++++
--
celsius::
+
--
https://en.wikipedia.org/wiki/Celsius[Celsius] is a temperature metric ranging from https://en.wikipedia.org/wiki/Absolute_zero[absolute zero] (-273.15&#176;) to infinity.
++++
<!-- üêñ ./main_runner.out
*C
C[0.0]
C[274.0]
C[-274.0]
-->
++++

[source,mmadt]
----
fhatos> *C
==>C?real<=real()[is(gte(-273.149994))]
fhatos> C[0.0]
==>C[0]
fhatos> C[274.0]
==>C[274]
fhatos> C[-274.0]
[ERROR] [/sys/scheduler] [/sys/type] -274.000000 is not a /mmadt/ext/C as defined by C()[is(gte(-273.149994))]
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'C[-274.0]')[cpp] [code=>'C[-274.0]']
----

++++
<!-- üêì -->
++++
--

====

==== The Frame

[stem]
++++
\tt{obj} := \tt{type}(\color{yellow}{\underline{\tt{frame}}})[\tt{value}]@\tt{ref}
++++

The [.h]#frame# of an `obj` is a set of fURI named variables that are dereferenceably accessible within the value of the `obj`.
If an `obj` has a specified frame, the `obj` is called an `inst` (instruction).
An `inst` is a function

[stem]
++++
f(\tt{obj}_\tt{in},a_1,a_2,\ldots,a_n) \mapsto \tt{obj}_\tt{out},
++++

where latexmath:[\tt{obj}_\tt{in}] is the _left hand side_ `obj` (input) and latexmath:[a_m] are the variables of the `obj` frame (arguments).

For instance:

++++
<!-- üêñ ./main_runner.out
int(a=>2)[*a]
4 + int(a=>2)[*a]
4 + int(a=>2)[+*a]
-->
++++

[source,mmadt]
----
fhatos> int(a=>2)[*a]
==>2
fhatos> 4 + int(a=>2)[*a]
==>6
fhatos> 4 + int(a=>2)[+*a]
==>10
----

++++
<!-- üêì -->
++++



==== The Value

[stem]
++++
\tt{obj} := \tt{type}(\tt{frame})[\color{yellow}{\underline{\tt{value}}}]@\tt{ref}
++++

The [.h]#value# of an `obj` is the datum specifying the __instance__ aspects of the `obj` within the boundaries of the __type__ aspects of the `obj`.

==== The Reference

[stem]
++++
\tt{obj} := \tt{type}(\tt{frame})[\tt{value}]@\color{yellow}{\underline{\tt{ref}}}
++++

The [.h]#reference# of an `obj` is a fURI denoting the location of the `obj` within the underlying structure.
The [aqua]*F*‚Äã[lime]#h#‚Äã[yellow]*a*‚Äã[red]*T*‚Äã[fuchsia]*O*‚Äã[blue]#S#‚Äã structure is the storage medium of all persistent `objs`.
If an `obj` does not have a reference, then the `obj` is transient -- existing only within the data flow.
When an `obj` has a reference, the `obj` encoding in the data flow (hardware main memory) and
within the structure ([red]*F*‚Äã[aqua]*H*‚Äã[blue]*A*‚Äã[yellow]#t#‚Äã[lime]*O*‚Äã[fuchsia]*s*‚Äã persistence) are synchronized.

[tabs]
====
memory::
+
--

++++
<!-- üêñ ./main_runner.out
a -> 'axel'
*a
*a + ' fantaxel'
*a
@a + ' fantaxel'
*a
-->
++++

[source,mmadt]
----
fhatos> a -> 'axel'
==>'axel'
fhatos> *a
==>'axel'
fhatos> *a + ' fantaxel'
==>'axel fantaxel'
fhatos> *a
==>'axel'
fhatos> @a + ' fantaxel'
==>'axel fantaxel'@a
fhatos> *a
==>'axel fantaxel'@a
----

++++
<!-- üêì -->
++++
--

thread::
+
--

++++
<!-- üêñ ./main_runner.out
thread[[ /
  loop=>from(a,0).plus(1).to(a).is(gt(10)).true.to(/abc/halt), /
  halt=>false, /
  delay=>nat[0]]]@abc
-->
++++

[source,mmadt]
----
fhatos> thread[[
          loop=>from(a,0).plus(1).to(a).is(gt(10)).true.to(/abc/halt),
          halt=>false,
          delay=>nat[0]]]@abc
=>thread[
==>loop=>from(a,0).plus(1).to(a).is(gt(10)).map(true).to(/abc/halt)
==>halt=>false
==>delay=>nat[0]
=>]@abc
----

++++
<!-- üêì -->
++++
--

====




.Controlling Base Value Bit Encoding
====
TIP: The bit-length of `int` and `real` can be specified at boot time via the boot-loader.
Other machines in the cluster with a different bit-length encodings can still be communicated with.
However, overflow is possible, but can be automatically checked using types in `/mmadt/ext/` such as:
`int8`, `int16`, `int32`.

[cols="5,5"]
|===

a|
++++
<!-- üêñ ./main_runner.out
int[6].inspect()
real[6.0].inspect()
-->
++++

[source,mmadt]
----
fhatos> int[6].inspect()
[ERROR] [/sys/scheduler] [/mmadt/int] /mmadt/inspect inst unresolved 
	         lhs id      inst id                        resolve obj                                                          
	  ->[/mmadt/int] /mmadt/int/::/mmadt/inspect => inspect(isa(/mmadt/int))[cpp]
	 -->[/mmadt/int] /mmadt/int/::/mmadt/inspect => inspect(isa(/mmadt/int))[cpp]
	--->[/mmadt/int] /mmadt/inspect              => inspect(isa(/mmadt/obj))                 
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'int[6].inspect()')[cpp] [code=>'int[6].inspect()']
fhatos> real[6.0].inspect()
[ERROR] [/sys/scheduler] [/mmadt/real] /mmadt/inspect inst unresolved 
	         lhs id       inst id                         resolve obj                                                           
	  ->[/mmadt/real] /mmadt/real/::/mmadt/inspect => inspect(isa(/mmadt/real))[cpp]
	 -->[/mmadt/real] /mmadt/real/::/mmadt/inspect => inspect(isa(/mmadt/real))[cpp]
	--->[/mmadt/real] /mmadt/inspect               => inspect(isa(/mmadt/obj))                  
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'real[6.0].inspect()')[cpp] [code=>'real[6.0].inspect()']
----

++++
<!-- üêì -->
++++

a|
++++
<!-- üêñ ./main_runner.out
/sys/router/config/resolve/auto_prefix -> /
  *(_) + \|[/mmadt/ext/]             --- <1>
a -> int8[126]                       --- <2>
@a + 1
@a + 1
@a + 1                               --- <3>
-->
++++

[source,mmadt]
----
fhatos> /sys/router/config/resolve/auto_prefix ->
          *(_) + \|[/mmadt/ext/]             // <1>
=>[
===>
===>/mmadt/
===>/mmadt/ext/
===>/fos/
===>/fos/sys/
===>/fos/io/
===>/fos/sensor/
===>/fos/ui/
===>/fos/util/
===>/sys/
===>/mmadt/ext/
=>]
fhatos> a -> int8[126]                       // <2>
==>int8[126]
fhatos> @a + 1
==>int8[127]@a
fhatos> @a + 1
==>int8[128]@a
fhatos> @a + 1                               // <3>
[ERROR] [/sys/scheduler] [/sys/type] 129@a is not a /mmadt/ext/int8 as defined by uint8()[is(gte(-127)).is(lte(128))]
	  thrown at inst int8[128]@a => plus(1)[cpp] [0=>1]
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'@a + 1                               // <3>')[cpp] [code=>'@a + 1                               // <3>']
----

++++
<!-- üêì -->
++++

<1> Including `/mmadt/ext` `objs` in the router's automatic URI resolution.
<2> Constructing an `int` constrained to values from `-127` to `128`.
<3> Triggering `int8` type error by overflowing its numeric range.

|===
====

==== Functional Types

The wildcard feature of the fURI scheme makes it possible to access instructions associated with a particular type.

++++
<!-- üêñ ./main_runner.out
*/mmadt/int/#
-->
++++

[source,mmadt]
----
fhatos> */mmadt/int/#
==>[int][[_]]
==>as?obj<=int(isa?noobj<=obj(/mmadt/uri)[noobj])[cpp]
==>div?int<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>gt?bool<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>gte?bool<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>inspect?rec<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>lt?bool<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>lte?bool<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>minus?int<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>mod?int<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>mult?int<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>neg?int<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
==>plus?int<=int(isa?noobj<=obj(/mmadt/int)[noobj])[cpp]
----

++++
<!-- üêì -->
++++

===== Sugar-Less mm-ADT

image:trill.png[width=150,float=right,title=trill] In the code example above, the expression to import `/mmadt/ext` is pretty intense looking, to say the least.

[source,mmadt]
----
/sys/router/config/resolve/auto_prefix ->  *(_) + \|[/mmadt/ext/]
----

The line above looks daunting because it contains numerous https://en.wikipedia.org/wiki/Syntactic_sugar[syntactic sugars].
Specifically, the binary and unary operators `->` (binary), `*` (unary), `_` (unary), `+` (binary), and `\|` (unary).
Each of these symbols ultimately parse down to an `inst`.
Each having that familiar functional form of `f(a,b,c,...)`.
For example, the _sugar free_ representation of the expression above is:

[cols="2,2"]
|===
a|
[source,mmadt]
----
start(</sys/router/config/resolve/auto_prefix>). // <1>
 ref(                                            // <2>
  from(_).                                       // <3>
  plus(                                          // <4>
    block(</mmadt/ext>)))                        // <5>
----
a|
<1> Evaluate the mm-ADT `bcode` with `uri[/sys/...]`.  `a ...`
<2> Use `uri[/sys/...]` as the address to store a value in an underlying structure. `a = ...`
<3> Fetch the value to store from the `uri[/sys/...]`. `a = get(a) ...`
<4> Add to the value stored at `uri[/sys/...]` to ... `a = get(a) + ...`.
<5> ... `uri[/mmadt/ext]`. `a = get(a) + b`.
|===

Given that `uri[/sys/router/config/resolve/auto_prefix]` resolves to a `lst` of `uris`,
`uri[/mmadt/ext]` is added that that `lst` and the updated `lst` is written back to
`uri[/sys/router/config/resolve/auto_prefix]`.

The one instruction that was not discussed above is `block` (sugar'd `|`).
This is perhaps the most useful instruction in the whole of mm-ADT and knowing how to uses is absoluately crucial to being competent with the language.
Moreover, when `block` is understood, so is a large portion of the language understood as well.
Before diving into `block`, it's important to first realize how instructions are evaluated.
For this, the fundamental, immutable instruction `apply` (sugar'd `.`) is the perfect place to start.

===== Inst Evaluation Mechanics

An mm-ADT `inst` is an https://en.wikipedia.org/wiki/Instruction_set_architecture#Instructions[instruction].
More generally, a https://en.wikipedia.org/wiki/Function_(computer_programming)[function].
More abstractly, a https://en.wikipedia.org/wiki/Function_(mathematics)[function].
Syntactically, an `inst` has the form:

[stem]
++++
\texttt{obj} := \texttt{type}(\texttt{frame})[\texttt{value}]@\texttt{ref}.
++++

Starting with the template above, components will be removed to highlight various `inst` forms and functions.

. latexmath:[\texttt{type}(\texttt{frame})[\texttt{value}\]@\texttt{ref}]: The complete form is a [.h]#referenced `inst`# and is used with coroutines.
. latexmath:[\texttt{type}(\texttt{frame})[\texttt{value}\]]: Without a reference location, the `obj` is a [.h]#standard `inst`#.
. latexmath:[\texttt{type}(\texttt{frame})[\]]: Without a reference or value, the `obj` is a [.h]#proto `inst`# resolved to a standard `inst` during compilation or runtime.
. latexmath:[\texttt{type}()[\]]: Without a reference, value, or frame, the `obj` is a [.h]#zero-arg proto `inst`# and is resolved during compilation or runtime.
. latexmath:[\texttt{type}]: Without a reference, value, frame, or respective tokens, the `obj` is an [.h]#`inst` reference# which can be dereferenced to yield the corresponding `inst` implementation.

[.center]
[source,mmadt]
----
type?rng{coeff}<=dom{coeff}(arg1, arg2, ...) [bcode]
----

[.center]
[stem]
++++
f(\mathcal{Dom}^{C} \times A_1 \times A_2 \times \ldots) \rightarrow \mathcal{Rng}^{C}
++++

The fURI query _type-specification_ is more advanced and requires an understanding of structure query processors.
As such, for now, realize an `inst` to have the form:

[.center]
[source,mmadt]
----
type(arg1, arg2, ...) [bcode]
----

[.center]
[stem]
++++
f(\mathcal{Obj}_{\texttt{dom}} \times A_1 \times A_2 \times \ldots) \rightarrow \mathcal{Obj}_{\texttt{rng}}
++++

In order to evaluate an `inst` an `obj` must be _applied_ to it.
Application is sugar'd `.`.

[.center]
[source,mmadt]
----
      inst(arg1, arg2, ...)
obj_d.inst(arg1, arg2, ...)
      inst(arg1, arg2, ...) => obj_r
----

When an `obj` is applied to an `inst`, the `obj` is called the _left-hand side_ `obj`.
This `obj` is the catalyst for a cascade of events that take place across the `inst` arguments and internal `bcode`.
The sequence of events are diagrammatically represented in the graphical explanation below where each line is a new timestep in the process.

[cols="6,9"]
|===
a|
[.center]
[source,mmadt]
----
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ     ‚îÇ
obj_d ‚îÄ‚îÄ‚îú‚îÄ> inst(arg1, arg2, ...)
        ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îå‚îÄ‚îò
        ‚îÇ               ‚îÇ   ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>[x.y.z]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> obj_r

----
a|
[.center]
[source,mmadt]
----
      inst(arg1, arg2, ...)             [x.y.z]             // <1>
obj_d.inst(arg1, arg2, ...)             [x.y.z]             // <2>
      inst(obj_d.arg1, obj_d.arg2, ...) [x.y.z]             // <3>
      inst(arg1_d, arg2_d, ...)         [obj_d.x.y.z]       // <4>
      inst(arg1_d, arg2_d, ...)         [x.y.z => obj_r]    // <5>
      inst(arg1, arg2, ...) => obj_r    [x.y.z]             // <6>
----
|===

<1> The `inst` with a collection of arguments and a `bcode` body called __inst_f__.
<2> A left-hand side `obj` is applied to the `inst`.
<3> The left-hand side `obj` is split across all arguments and applied to each.
<4> When all argument applications have completed, the left-hand side `obj` percolates through the `bcode`.
<5> The right-hand side `obj` produced by the `bcode` is the result of the application.
<6> The right-hand side `obj` becomes the input to the next `inst` in the large `bcode` expression (not shown).

The diagram states that the input `obj` is applied to each argument, the result of which are the actual arguments provided to the `inst`.
The `inst` is thus, generally defined as:

[.center]
[stem]
++++
\[
\begin{align*}
x \cdot f(args...) & \rightarrow y \\
f(x,x \cdot args...) & \rightarrow y \\
f(x,x \cdot args_1, x \cdot args_2, ...) & \rightarrow y \\
\end{align*}
\]
++++

What separates `inst` from other `poly` types such as `lst` and `rec` (discussed next) is that it mounts a https://en.wikipedia.org/wiki/Thread-local_storage[thread-local] structure on the router called a `fos:frame`.
The router supports a chain `fos:frame` structures and, in this way, `fos:frame` serves the purpose of a https://en.wikipedia.org/wiki/Call_stack[callstack], where the arguments of the `inst` can be dereferenced within the body of the `inst`.

++++
<!-- üêñ ./main_runner.out "34.make_bigger(a=>plus(10))[plus(*a)]" -->
++++

[source,mmadt]
----
fhatos> 34.make_bigger(a=>plus(10))[plus(*a)]
==>78
----

++++
<!-- üêì -->
++++

In the example above, `make_bigger` is defined "on the fly" (a "named lambda", if one chooses to see it as such) where the argument `a` can be dereferenced within the body of the `inst` `[ ... ]`.
The input to the body of the `inst` is, as can be expected, the left-hand side `int[34]`.

===== Generalized Poly Evaluation Mechanics

image:sopapilla.png[width=150,float=left,title=sopapilla]  The `fos:frame` is the only aspect of an `inst` that makes it unique because every `poly`-type supports the same internally recursive application of an left-hand side `obj`.
For example, see how the internal `objs` if a `lst` are effected by the application of an `obj` outside of the `lst`.

====== Lst Application

++++
<!-- üêñ ./main_runner.out
2.lst[[1,plus(2),mult(plus(3)),'a']]
-->
++++

[source,mmadt]
----
fhatos> 2.lst[[1,plus(2),mult(plus(3)),'a']]
=>[
===>1
===>4
===>10
===>'a'
=>]
----

++++
<!-- üêì -->
++++

Note that the application is recursive.
For example, `2.mult(plus(3))` is evaluated as follows:

[.center]
[stem]
++++
\[
\begin{align*}
2 \cdot \times(+(3)) & \rightarrow 10 \\
\times(2,2 \cdot +(3)) & \rightarrow 10 \\
\times(2, +(2,2 \cdot 3)) & \rightarrow 10 \\
\times(2, +(2,3)) & \rightarrow 10 \\
\times(2, 5) & \rightarrow 10 \\
10 & \rightarrow 10 \\
\end{align*}
\]
++++

====== Rec Application

A `rec` behaves in a similar manner to `lst` and `inst` when a left-hand side `obj` is applied to it.
However, what makes
`rec` interesting and useful beyond a data storage structure is it's _delayed evaluation semantics_ denoted by `=>`.

++++
<!-- üêñ ./main_runner.out
2.rec[[is(gt(2)) => plus(2), _ => 0]]
-->
++++

[source,mmadt]
----
fhatos> 2.rec[[is(gt(2)) => plus(2), _ => 0]]
=>[
==>2=>0
=>]
----

++++
<!-- üêì -->
++++

This feature of `rec` make it both a https://en.wikipedia.org/wiki/Data_structure[data structure] and a https://en.wikipedia.org/wiki/Control_flow[flow control structure] as once an `obj` has been applied to `rec`, the values of `rec` can be "drained".
For instance, `if` is implemented with a two entry `rec`, where one entry maps to `noobj`.

++++
<!-- üêñ ./main_runner.out
/io/console/config/nest -> 0                  --- <1>
{1,2,3}.[is(gt(2)) => _, _ => noobj]          --- <2>
{1,2,3}.[is(gt(2)) => _, _ => noobj]>-        --- <3>
-->
++++

[source,mmadt]
----
fhatos> /io/console/config/nest -> 0                  // <1>
==>0
fhatos> {1,2,3}.[is(gt(2)) => _, _ => noobj]          // <2>
==>[1=>noobj]
==>[2=>noobj]
==>[3=>_]
fhatos> {1,2,3}.[is(gt(2)) => _, _ => noobj]>-        // <3>
==>3
----

++++
<!-- üêì -->
++++

<1> Reducing the console's display depth for nested structures (purely aesthetic).
<2> A stream of `objs` is applied one-by-one to the `rec` yielding a new internally-applied `rec`.
<3> The internally-applied `rec` is "drained" via the `merge` `inst` (sugar'd `>-`).

In the above example, since `1` and `2` were mapped to `noobj`, they are effectively removed from the execution pipeline.
However, because `3` is `gt(2)`, it is mapped to `_` (its self).
Thus, when `>-` is applied to this `rec`, the result is
`{noobj,noobj,3}` which is equivalent to `{3}`.
In this way, `rec` is both a data structure and a flow control structure.

It's not difficult to realize how an "if"-`rec` generalizes to support the various plays on one of computing's most important concepts: https://en.wikipedia.org/wiki/Branch_(computer_science)[the branch].

[tabs]
====
if-else::
+
--
++++
<!-- üêñ ./main_runner.out
[HEADER] .if-else icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#If%E2%80%93then(%E2%80%93else),2x,role=blue]
{1,2,3}.[                  /
  ?>2 => mult(-1),   /
  _   => mult(100)]>-
-->
++++

.if-else icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#If%E2%80%93then(%E2%80%93else),2x,role=blue]
[source,mmadt]
----
fhatos> {1,2,3}.[                 
          ?>2 => mult(-1),  
          _   => mult(100)]>-
==>100
==>200
==>-3
----

++++
<!-- üêì -->
++++
--
switch::
+
--

++++
<!-- üêñ ./main_runner.out
[HEADER] .switch icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Case_and_switch_statements,2x,role=blue]
{1,2,3}.[             /
  ?=1 => mult(-1),    /
  ?=2 => mult(0),     /
  ?=3 => _]>-
-->
++++

.switch icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Case_and_switch_statements,2x,role=blue]
[source,mmadt]
----
fhatos> {1,2,3}.[            
          ?=1 => mult(-1),   
          ?=2 => mult(0),    
          ?=3 => _]>-
==>-1
==>0
==>3
----

++++
<!-- üêì -->
++++
--
guard::
+
--

++++
<!-- üêñ ./main_runner.out
[HEADER] .guard icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Guarded_conditionals,2x,role=blue]
{1,2,3}.[
-->
++++

.guard icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Guarded_conditionals,2x,role=blue]
[source,mmadt]
----
fhatos> {1,2,3}.[
==>1
==>2
==>3
----

++++
<!-- üêì -->
++++
--

pattern::
+
--

++++
<!-- üêñ ./main_runner.out
[HEADER] .pattern-match icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Pattern_matching,2x,role=blue]
--- todo
-->
++++

.pattern-match icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Pattern_matching,2x,role=blue]
[source,mmadt]
----
fhatos> --- todo
----

++++
<!-- üêì -->
++++
--

hash::
+
--
++++
<!-- üêñ ./main_runner.out
[HEADER] .conditional hash icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Hash-based_conditionals,2x,role=blue]
--- todo
-->
++++

.conditional hash icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Hash-based_conditionals,2x,role=blue]
[source,mmadt]
----
fhatos> --- todo
----

++++
<!-- üêì -->
++++
--
====

====
NOTE: The `merge` (sugar'd `>-`) instruction has a correlate: `split` (sugar'd `-<`).
The way to think of these two instructions is that they either branch a serial execution pipeline (`split`) or the join a collection of parallel executing pipelines (`merge`).
Interestingly, the application of an `obj` to a `poly` implements the `split` instruction.
So why does an explicit `split` instruction exist?
Because there are other ways in which branching pipelines can be defined and evaluated.
This will be discussed later when discussing `fos:thread`, `fos:coroutine`, and `fos:fiber`.
====

====== Obj Application

The universal application of `.` (apply) implies that every `obj` is a function as every `obj` can have another `obj` applied to it.
This is, in fact, the case.

++++
<!-- üêñ ./main_runner.out
1.plus(1)         // <1>
1. 2              // <2>
1.2.2             // <3>
[1,2,3].<1>       // <4>
[a=>1,b=>2].b     // <5>
-->
++++

[source,mmadt]
----
fhatos> 1.plus(1)         // <1>
==>2
fhatos> 1. 2              // <2>
==>2
fhatos> 1.2.2             // <3>
==>2
fhatos> [1,2,3].<1>       // <4>
==>2
fhatos> [a=>1,b=>2].b     // <5>
==>2
----

++++
<!-- üêì -->
++++

<1> `int[1]` applied to `inst[plus(1)]`.
<2> `int[1]` applied to `int[2]` (the space before `.` is necessary to avoid parsing as a `real`).
<3> `real[1.2]` applied to `int[2]`.
<4> `lst\[[1,2,3]]` applied to the `uri[1]`.
<5> `rec\[[a=>1,b=>2]]` applied to the `uri[b]`.

[.small]
[.center]
[cols="1,1,1,1,1,1,1,1,1,1,1",width=75%]
|===
|  X   | noobj | bool | int | real | str | uri | lst | rec | inst | bcode
|noobj |    x  |  y   |    z| a    |  b  |  c  |  d  |  e  |  f   |  g
|bool  |    x  |   y  |   z |  a   |   b |   c |   d |   e |   f  |   g
|int   |     x |  y   |  z  |   a  | b   | c   |  d  | e   |  f   |    g
|real  |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|str   |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|uri   |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|lst   |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|rec   |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|inst  |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|bcode |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g

|===

==== Values

===== By Value vs. By Reference

[cols="2,2"]
|===
a|
[source,mmadt]
----
age[45]@x => plus(10) => age[55]@x
    ^                        ^
   @\|                        \|
    x------------------------/
   *\|
    v
age[45]  =>  plus(10) => age[55]
----
a|

++++
<!-- üêñ ./main_runner.out
age -> \|(is(gt(0)).is(lt(120)))
a -> age[45]
*a.inspect()
@a.inspect()
-->
++++

[source,mmadt]
----
fhatos> age -> \|(is(gt(0)).is(lt(120)))
==>is?noobj<=obj(gt?noobj<=obj(0)[noobj])[noobj].is?noobj<=obj(lt?noobj<=obj(120)[noobj])[noobj]
fhatos> a -> age[45]
==>age[45]
fhatos> *a.inspect()
[ERROR] [/sys/scheduler] [/mmadt/bcode] /mmadt/inspect inst unresolved 
	         lhs id        inst id                          resolve obj                                                           
	  ->[/mmadt/bcode] /mmadt/bcode/::/mmadt/inspect => inspect(isa(/mmadt/bool))[cpp]
	 -->[/mmadt/bcode] /mmadt/bcode/::/mmadt/inspect => inspect(isa(/mmadt/bool))[cpp]
	--->[/mmadt/bcode] /mmadt/inspect                => inspect(isa(/mmadt/obj))                  
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'*a.inspect()')[cpp] [code=>'*a.inspect()']
fhatos> @a.inspect()
[ERROR] [/sys/scheduler] [/mmadt/bcode] /mmadt/inspect inst unresolved 
	         lhs id        inst id                          resolve obj                                                           
	  ->[/mmadt/bcode] /mmadt/bcode/::/mmadt/inspect => inspect(isa(/mmadt/bool))[cpp]
	 -->[/mmadt/bcode] /mmadt/bcode/::/mmadt/inspect => inspect(isa(/mmadt/bool))[cpp]
	--->[/mmadt/bcode] /mmadt/inspect                => inspect(isa(/mmadt/obj))                  
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'@a.inspect()')[cpp] [code=>'@a.inspect()']
----

++++
<!-- üêì -->
++++

|===

++++
<!-- üêñ ./main_runner.out "a?sub -> |print(_)" "a -> 12" "@a.inspect()" "@a.plus(1)" "@a.plus(1).plus(1)" -->
++++

[source,mmadt]
----
fhatos> a?sub -> |print(_)
==>print?noobj<=obj(_)[noobj]
fhatos> a -> 12
==>12
12fhatos> @a.inspect()
[ERROR] [/sys/scheduler] [a] /mmadt/inspect inst unresolved 
	         lhs id  inst id                        resolve obj                                                          
	  ->[a] /mmadt/int/::/mmadt/inspect => inspect(isa(/mmadt/int))[cpp]
	 -->[a] /mmadt/int/::/mmadt/inspect => inspect(isa(/mmadt/int))[cpp]
	--->[a] /mmadt/inspect              => inspect(isa(/mmadt/obj))                 
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'@a.inspect()')[cpp] [code=>'@a.inspect()']
fhatos> @a.plus(1)
12@a==>13@a
13@afhatos> @a.plus(1).plus(1)
==>15@a
----

++++
<!-- üêì -->
++++

==== Types

Every mmADT `obj` is typed.
A type is an mmADT `obj`.
A `obj` can serve as a value in one situation and as a type in another.
Types can be typed.

===== Bytecode and Instruction Types

===== User Defined Types

image:ginger.png[width=140,float=left]  mm-ADT is a structurally typed language, whereby if an `obj` *A* __matches__ `obj` *B*, then *A* is _a type of_ *B*.
An `obj` type is a simply an mm-ADT program that verifies instances of the type.
For instance, if a natural number stem:[\mathbb{N}] is any non-negative number, then natural numbers are a subset (or refinement) of `int`.

++++
<!-- üêñ ./main_runner.out "/type/int/nat -> |is(gt(0))" "nat[6]" "nat[-6]" "nat[3].plus(2)" "nat[3].mult(-2)" -->
++++

[source,mmadt]
----
fhatos> /type/int/nat -> |is(gt(0))
[ERROR] [/sys/router] no mounted structure for /type/int/nat  
==>is?noobj<=obj(gt?noobj<=obj(0)[noobj])[noobj]
fhatos> nat[6]
==>nat[6]
fhatos> nat[-6]
[ERROR] [/sys/scheduler] [/sys/type] -6 is not a /mmadt/ext/nat as defined by nat()[is(gte(0))]
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'nat[-6]')[cpp] [code=>'nat[-6]']
fhatos> nat[3].plus(2)
==>nat[5]
fhatos> nat[3].mult(-2)
[ERROR] [/sys/scheduler] [/sys/type] -6 is not a /mmadt/ext/nat as defined by nat()[is(gte(0))]
	  thrown at inst nat[3] => mult(-2)[cpp] [0=>-2]
	  thrown at inst console[[halt=>false,delay=>nat[0],loop=>inst()[cpp],config=>[nest=>2,prompt=>'fhatos> ',strict=>false,log=>INFO,stack_size=>24288,stack_trace=>true]]]@/io/console => eval?obj{?}<=console(code=>'nat[3].mult(-2)')[cpp] [code=>'nat[3].mult(-2)']
----

++++
<!-- üêì -->
++++

===== Process Types

A simple mm-ADT program is defined below.
The program is a specialization of the poly-type `rec` called `thread`, where `thread` is abstractly defined as

++++
<!-- ./main_runner.out
threadx[[ /
  halt=>false, /
  delay=>nat[0], /
  loop=>from(|a,0).plus(1).to(a).print(_). /
         [is(gt(10)) => |true.to(abc/halt)]>-]]@abc
@abc.spawn()
-->
++++

The `thread` object is published to the fURI endpoint `esp32@127.0.0.1/scheduler/threads/logger`.
The scheduler spawns the program on an individual `thread` accessible via the target fURI.
Once spawned, the `setup` function prints the thread's id and halts.

++++
<!-- #############################################################################################################
     #############################################################################################################
     ############################################ ROUTER #########################################################
     #############################################################################################################
     ############################################################################################################# -->
++++

=== The Router Structure

image:cooties-2.png[width=140,float=right] Every fhatOS machine has a single _router_.
The function of the router is to:

. Route read/write requests to respective structures.
. Coordinate with remote routers on remote read/write requests.
. Manage pattern conflicts between structures.
. Manage fURI query extensions (`?` modulators).

++++
<!-- üêñ ./main_runner.out "/io/console/config/nest->3" "*/sys/router/#/" -->
++++

[source,mmadt]
----
fhatos> /io/console/config/nest->3
==>3
fhatos> */sys/router/#/
=>[
==>/sys/router=>[
===>structure=>[
====>/sys/#
====>/mnt/#
====>/boot/#
====>/fos/#
====>/mmadt/#
====>/io/#
====>+/#
====>/disk/#
====>/shared/#
====>/bus/#
==>]
===>frame=>[rec][_]
===>config=>[
====>resolve=>[namespace=>[:=>/mmadt/,fos:=>/fos/],auto_prefix=>[,/mmadt/,/mmadt/ext/,/fos/,/fos/sys/,/fos/io/,/fos/sensor/,/fos/ui/,/fos/util/,/sys/],query=>[write=>[lock=>to_do]],default_config=>[query=>[write=>[sub=>noobj]]]]
==>]
===>query=>[
====>write=>[lock=>lock?obj{?}<=obj{?}()[cpp],sub=>sub?obj{?}<=obj()[cpp]]
==>]
=>]@/sys/router
=>]
----

++++
<!-- üêì -->
++++

The router manages access to physical memory.
Physical memory is partitioned by *structures*.
The address space of a structure is the (query-less) fURI.
Structures have an associated *pattern* fURI defining the boundaries of their storage space.
Structures can not have overlapping address spaces.
Every structure implements the `structure.hpp` and ultimately, is an `obj`.

- There are structures that encode `objs` in physical memory (e.g. `heap`).
- There are structures that encode `objs` on disk (e.g. `fs` -- filesystem).
- There are structures that encode `objs` on a remote broker (e.g. `mqtt`).
- There are structures that encode `objs` in the Bluetooth hierarchy (e.g. `bt`).
- There are structures that encode `objs` on RFID chips (e.g. `rfid`).
- There are structures that encode `objs` as scoped variables when evaluating code (e.g. `frame`).
- There are structures that encode other structures (e.g. `mnt`).

The aggregate of all structures accessible through the router defines the complete memory footprint of a [blue]*F*‚Äã[red]#H#‚Äã[aqua]*a*‚Äã[yellow]#t#‚Äã[lime]#O#‚Äã[fuchsia]*s*‚Äã instance.

++++
<!-- üêñ ./main_runner.out
a -> 'snowbutt'            --- <1>
*a                         --- <2>
a?sub -> |to(b)            --- <3>
*a?sub                     --- <4>
a -> 'meangirl'            --- <5>
*b                         --- <6>
-->
++++

[source,mmadt]
----
fhatos> a -> 'snowbutt'            // <1>
==>'snowbutt'
fhatos> *a                         // <2>
==>'snowbutt'
fhatos> a?sub -> |to(b)            // <3>
==>to?noobj<=obj(b)[noobj]
fhatos> *a?sub                     // <4>
==>a?bool<=obj(_)[cpp]
fhatos> a -> 'meangirl'            // <5>
==>'meangirl'
fhatos> *b                         // <6>
==>'meangirl'
----

++++
<!-- üêì -->
++++

<1> A request to write `str['snowbutt']` to `uri[a]` is sent to the router.
<2> A request to read the `obj` at `uri[a]` is sent to the router.
<3> A subscription request to receive notifications about `uri[a]` is sent to the router.
<4> A request to read the subscriptions of `uri[a]` is sent to the router.
<5> A request to write `str['meangirl']` to `uri[a]` is sent to the router.
<6> A request to read `uri[b]` is sent to the router.

The above example makes salient the router's role is structure usage.
Not only are read/write requests managed by the router, but also subscriptions and the evaluation of their associated `on_recv`-code.
However, ultimately, the router serves as a simple singleton proxy to the structures it manages.
It's in the structures where the heavily lifting of the memory operations takes place.

==== Structure Reading and Writing

Every structure supports 2 primary operations:

[.center]
[cols="2,2",width=75%]
|===
a|

\$\text{read} : U \rightarrow O\$

The router is given a fURI `u` from `U`.
The router locates the `structure` responsible for the fURI subspace containing `u`.
The `structure` resolves `u` to an `obj`. If no `obj` is found, `noobj` is returned.

a|
++++
<!-- üêñ ./main_runner.out
[HIDDEN] u -> 'fhatos'
from(u)
*u
-->
++++

[source,mmadt]
----
fhatos> from(u)
==>'fhatos'
fhatos> *u
==>'fhatos'
----

++++
<!-- üêì -->
++++

a|
\$\text{write}: (U \times O) \rightarrow \emptyset\$

a|
++++
<!-- üêñ ./main_runner.out
u -> o
u.ref(o)
o.to(u)
-->
++++

[source,mmadt]
----
fhatos> u -> o
==>o
fhatos> u.ref(o)
==>o
fhatos> o.to(u)
==>o
----

++++
<!-- üêì -->
++++
|===

A read accepts a direct fURI (called an `id`) or a match fURI (called a `pattern`).
Within the category of `id` and `pattern`, there are `node` fURIs and `branch` fURIs.
An example itemization is provided below:

* `id`: an unambiguous fURI that references a single address space in the structure.
** `node`: the address of a specific `obj`.
** `branch`: the root address of a collection of `objs`.
* `pattern`: a fURI containing one or more wildcard characters (`+` or `#`) in it's path.
** `node`: a pattern referencing zero or more `objs`.
** `branch`: a pattern referencing zero or more collections of `objs`.

[cols="3,5"]
|===

a|
++++
<!-- üêñ ./main_runner.out
a/a -> 1; a/b -> 2; a/b/c -> 3; a/b/d -> 4;
*a/b            --- <1>
*a/b/           --- <2>
*a/+            --- <3>
*a/+/           --- <4>
*a/#            --- <5>
*a/#/           --- <6>
-->
++++

[source,mmadt]
----
fhatos> a/a -> 1; a/b -> 2; a/b/c -> 3; a/b/d -> 4;
fhatos> *a/b            // <1>
==>2
fhatos> *a/b/           // <2>
=>[
==>a/b/c=>3
==>a/b/d=>4
=>]
fhatos> *a/+            // <3>
==>1
==>2
fhatos> *a/+/           // <4>
=>[
==>a/b/c=>3
==>a/b/d=>4
=>]
fhatos> *a/#            // <5>
==>1
==>2
==>3
==>4
fhatos> *a/#/           // <6>
=>[
==>a/a=>1
==>a/b=>2
==>a/b/c=>3
==>a/b/d=>4
=>]
----

++++
<!-- üêì -->
++++

a|

++++
TIP: The first line in the example appears to be 4 https://en.wikipedia.org/wiki/Pascal_(programming_language)#Semicolons_as_statement_separators[individual statements].
In fact, it is a single fluent expression. The signature of the `end` `inst` (sugar'd `;`) is `end?obj{0}\<=obj{*}`.
This barrier step computes all monads up to it before emitting a `noobj` monad.
With `end`, it's possible to write mm-ADT in the classic statement-oriented, imperative-style where semincolons (effectively) separate atomic operations.
++++

<1> Dereferencing an `id`-node fURI to access a single `obj`.
<2> Dereferencing an `id`-branch fURI to access a collection of `objs`.
<3> Dereferencing a `pattern`-node fURI to access `objs` at respective nodes.
<4> Dereferencing a `pattern`-branch fURI to access `objs` at respective branches.

|===

===== Query Processors

Every fURI can have any number of key/value(s) pairs attached to it via the `?` query encoding scheme defined by the
https://datatracker.ietf.org/doc/html/rfc3986#section-3.4[W3C URI] specification.
Modules can be added to structures enabling different behaviors on read/write given associated, relevant `?` parameters.
Example modules that come preloaded with [lime]#f#‚Äã[aqua]#h#‚Äã[fuchsia]*A*‚Äã[blue]*T*‚Äã[red]#o#‚Äã[yellow]#s#‚Äã are:

. `pubsub`: supports asynchronous, event-based access to structure `objs`.
.. `a?sub -> _` (subscribe )
.. `a?sub -> noobj` (unsubscribe)
.. `sub[source=>uri, pattern=>uri, on_recv=>obj]`
.. `msg[target=>uri, payload=>obj, retain=>bool]`
. `lock`: provides resource locking semantics to reading and writing `objs` in a concurrent environment.
.. `a?lock=w` (prevent writes to the `obj` at `a`)
.. `a?lock=rw` (prevent reads and writes to the `obj` at `a`)
.. `a?lock=false` (unlock the `obj` at `a`)
. `type`: provides an `obj` type system encoded within an `obj's` type fURI.
.. `nat?dom=int&dc=1,1&rng=int&rc=1,1` (the `inst` signature of `nat?int<=int()[...]`)

Other modules can be created and deployed across a [fuchsia]#F#‚Äã[blue]*H*‚Äã[aqua]#a#‚Äã[red]*T*‚Äã[yellow]*o*‚Äã[lime]*S*‚Äã cluster.

.Query Free fURIs
****
IMPORTANT: The address space of a structures does not include the query parameters.
Query parameters are used by structures to modulate the semantics of a read/write operation and are never used as the address of an `obj`.
However, nothing prevents the `obj` at an address to be a `uri[]` with a query.
Be sure to use the non-sugar'd `< >` fURI syntax when multiple values are associated with a key as the value separating
`,` will be preferentially parsed as a `lst`, `rec`, or `inst` argument separator.
++++
<!-- üêñ ./main_runner.out
abc?k1=v1&k2=v2&k3=v3                     --- <1>
abc?k1=v1,v2&k2=v3&k3=v4,v5,v6            --- <2>
<abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>          --- <3>
<abc?k1=v1,v2&k2=v3&k3=v4,v5,v6> -> 12    --- <4>
*abc
abc -> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>   --- <5>
*abc
-->
++++

[source,mmadt]
----
fhatos> abc?k1=v1&k2=v2&k3=v3                     // <1>
==>abc?k1=v1&k2=v2&k3=v3
fhatos> abc?k1=v1,v2&k2=v3&k3=v4,v5,v6            // <2>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>          // <3>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6> -> 12    // <4>
[ERROR] [/sys/router] [/mnt/cache] no query processor for k1=v1,v2&k2=v3&k3=v4,v5,v6 on write
==>12
fhatos> *abc
fhatos> abc -> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>   // <5>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> *abc
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
----

++++
<!-- üêì -->
++++

<1> Sugar'd `uri` syntax can be used when no commas are present in the fURI.
<2> Multiple values are deliminated using commas.
<3> To ensure proper parsing, multi-value query `uris[]` should be wrapped in `< >` brackets.
<4> The query of a fURI is stripped when used as a structure address.
<5> The query of a fURI is not stripped when used as a value at a struture address.

****

[source,mmadt]
----
1.plus(2)
----

[cols="7,8"]
|===
a|
++++
<!-- üêñ ./main_runner.out
*a
*b
b -> 12
a -> b
*a
**a
-->
++++

[source,mmadt]
----
fhatos> *a
==>a?bool<=obj(_)[cpp]
fhatos> *b
fhatos> b -> 12
==>12
fhatos> a -> b
==>b
fhatos> *a
==>b
fhatos> **a
==>12
----

++++
<!-- üêì -->
++++

a|
[source,mmadt]
----
   [‚ñ†]                         [‚ñ†]
  /   \                       /   \
 /     \                     /     \
[‚ñ†]    [‚ñ†]                  [‚ñ†]    [‚ñ†]
      /   \                       /   \
     /     \                     /     \
   [‚ñ†]     [b]@x ------------> [12]@b  [‚ñ†]
----
`b` references `12`. `a` references `b`. a double dereferences jumps the monad from `a` to `b` to `12`.
a|
++++
<!-- üêñ ./main_runner.out
a -> 12
*a.plus(10)
*a
@a
@a.plus(10)
*a
-->
++++

[source,mmadt]
----
fhatos> a -> 12
==>12
fhatos> *a.plus(10)
==>22
fhatos> *a
==>12
fhatos> @a
==>12@a
fhatos> @a.plus(10)
==>22@a
fhatos> *a
==>22@a
----

++++
<!-- üêì -->
++++

a|
[source,mmadt]
----
   [‚ñ†]                          [‚ñ†]
  /   \                        /   \
 /     \                      /     \
[‚ñ†]    [‚ñ†]                   [‚ñ†]    [‚ñ†]
      /   \                           \
     /     \         @a.plus(10)       \
   [‚ñ†]     [12]@a ------------------> [22]@a
----
`12` is written to `a`. `10` is added to `a` (*pass by value* `*`). `a` still stores `12`. `10` is added to `a` (**pass by reference** `@`). `a` now stores `22`.
a|
++++
<!-- üêñ ./main_runner.out "a?sub -> \|to(b)" "*a?sub" "*b" "a->12" "*a" "*b" -->
++++

[source,mmadt]
----
fhatos> a?sub -> \|to(b)
==>to?noobj<=obj(b)[noobj]
fhatos> *a?sub
==>a?bool<=obj(_)[cpp]
fhatos> *b
fhatos> a->12
==>12
fhatos> *a
==>12
fhatos> *b
==>12
----

++++
<!-- üêì -->
++++


[source,mmadt]
----
fhatos> a?sub -> \|to(b)
[INFO]  [/mnt/cache] [/sys/scheduler]=subscribe=>[+/#]
==>to?obj<=obj(b)[noobj]
fhatos> *a?sub
fhatos> *b
fhatos> a->12
==>12
fhatos> *a
==>12
fhatos> *b
==>12

----

a|
[source,mmadt]
----
   [‚ñ†]                          [‚ñ†]
  /   \                        /   \
 /     \                      /     \
[‚ñ†]    [‚ñ†]        [sub]     [‚ñ†]     [‚ñ†]
      /   \      .     .   /   \
     /     \    .       . /     \
   [‚ñ†]     [12]@a       [12]@b  [‚ñ†]
----
subscribes to `a` with bcode of the form \$f(a) -> b\$. `12` is written to `a` which triggers the subscription bcode to write `12` to `b`.
|===

==== Embedding

mm-ADT was designed to support the creation and manipulation of _abstract data types_ -- the "ADT" in mm-ADT.
When expressing abstract data types is natural, then it's possible to leverage _multiple models_ such as key/value, document, relational, vector, graph, and the various nooks and crannies between -- the "mm" in mm-ADT.

mm-ADT's URI addressing scheme makes it possible to _embed_ an array data types into the underlying [blue]*F*‚Äã[red]#h#‚Äã[lime]*A*‚Äã[fuchsia]*T*‚Äã[yellow]*O*‚Äã[aqua]#s#‚Äã structure.
This section will explore the following considerations when designing a _multi-model abstract data type_.

. **spatial encodings**
. **schema encodings**
. **language encodings**

===== Spatial Consideration when Embedding

++++
<!-- üêñ ./main_runner.out
1.plus(2)
-->
++++

[source,mmadt]
----
fhatos> 1.plus(2)
==>3
----

++++
<!-- üêì -->
++++

A _matrix_ is an \$n \times m\$ data structure composed of \$n\$ vectors/row, each with \$m\$ elements/columns.
A relational database _table_ is an example of a matrix, where the entries typically span numeric and non-numeric data types.
Three general approaches to embedding a matrix or table into a `fos:structure` are presented below, where each makes different space/time tradeoffs.

[cols="5,5,5",separator=üß±]
|===
^aüß±
[.big]
[source,mmadt]
----
 \    |   |    /
 [‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]

 -[‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]-

 [‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]
 /    |   |    \

----
^aüß±
[.big]
[source,mmadt]
----
‚Äã
[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]

[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]

[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
‚Äã
----

^aüß±
[.big]
[source,mmadt]
----
‚Äã
[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
|   |   |   |
[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
|   |   |   |
[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
‚Äã
----
aüß±
++++
<!-- üêñ ./main_runner.out
--- write matrix
m/0/0 -> 0
m/0/1 -> 1
m/0/2 -> 2
m/0/3 -> 3
m/1/0 -> 4
m/1/1 -> 5
m/1/2 -> 6
m/1/3 -> 7
m/2/0 -> 8
m/2/1 -> 9
m/2/2 -> 10
m/2/3 -> 11
--- read matrix
*m/0/0      --- <1>
*m/0/+      --- <2>
*m/+/0      --- <3>
-->
++++

[source,mmadt]
----
fhatos> --- write matrix
fhatos> m/0/0 -> 0
==>0
fhatos> m/0/1 -> 1
==>1
fhatos> m/0/2 -> 2
==>2
fhatos> m/0/3 -> 3
==>3
fhatos> m/1/0 -> 4
==>4
fhatos> m/1/1 -> 5
==>5
fhatos> m/1/2 -> 6
==>6
fhatos> m/1/3 -> 7
==>7
fhatos> m/2/0 -> 8
==>8
fhatos> m/2/1 -> 9
==>9
fhatos> m/2/2 -> 10
==>10
fhatos> m/2/3 -> 11
==>11
fhatos> --- read matrix
==>x
fhatos> *m/0/0      // <1>
==>0
fhatos> *m/0/+      // <2>
==>0
==>1
==>2
==>3
fhatos> *m/+/0      // <3>
==>0
==>4
==>8
----

++++
<!-- üêì -->
++++

aüß±
++++

<!-- üêñ ./main_runner.out --- write matrix m/0 -> [0,1,2,3]
m/1 -> [4,5,6,7]
m/2 -> [8,9,10,11]
--- read matrix *m/0/0 --- <1> *m/0/+ --- <2> *m/+/0 --- <3> -->

++++

[source,mmadt]
----
fhatos> --- write matrix
fhatos> m/0 -> [0,1,2,3]
=>[
===>0
===>1
===>2
===>3
=>]
fhatos> m/1 -> [4,5,6,7]
=>[
===>4
===>5
===>6
===>7
=>]
fhatos> m/2 -> [8,9,10,11]
=>[
===>8
===>9
===>10
===>11
=>]
fhatos> --- read matrix
==>x
fhatos> *m/0/0      // <1>
==>0
fhatos> *m/0/+      // <2>
==>0
==>1
==>2
==>3
fhatos> *m/+/0      // <3>
==>0
==>4
==>8
----

++++

<!-- üêì -->

++++

aüß±
++++

<!-- üêñ ./main_runner.out --- write matrix m -> [[0,1,2,3], /
[4,5,6,7], /
[8,9,10,11]]
--- read matrix *m/0/0 --- <1> *m/0/+ --- <2> *m/+/0 --- <3> -->

++++

[source,mmadt]
----
fhatos> --- write matrix
fhatos> m -> [[0,1,2,3],
              [4,5,6,7],
              [8,9,10,11]]
=>[
=>[
===>0
===>1
===>2
===>3
=>]
=>[
===>4
===>5
===>6
===>7
=>]
=>[
===>8
===>9
===>10
===>11
=>]
=>]
fhatos> --- read matrix
==>x
fhatos> *m/0/0      // <1>
==>0
fhatos> *m/0/+      // <2>
==>0
==>1
==>2
==>3
fhatos> *m/+/0      // <3>
==>0
==>4
==>8
----

++++

<!-- üêì -->

++++

|===

<1> Retrieve the first element of matrix `m`.
<2> Retrieve the first row of matrix `m`.
<3> Retrieve the first column of matrix `m`.

The above example demonstrates the power of structural embeddings.
The platonic matrix `m` was embedded in a structure using 3 different representations: _entry-wise_, _row-wise_, and _row-column wise_.
Next, each embedding was read: an _element read_, a _row read_ and a _column read_.
The expression used to read from each of the three embeddings is the same and so is the result.
This is possible because a structure resolves up the fURI path hierarchy until it finds a match.
Once found, it then traverses within the match to resolve the remaining path segments.

.Amortized Costs in Terms of Time
[.small][.center]
[%header,width=50%,cols="l2,c1,c1,c1"]
|===
| embedding              | single-element | row-access  | column-access
| [.red]#entry#          | \$O(1)\$       | \$O(n)\$    | \$O(m)\$
| [.red]#row#            | \$O(m)\$       | \$O(1)\$    | \$O(m)\$
| [.red]#row_column#     | \$O(1)\$       | \$O(1)\$    | \$O(1)\$
|===

The different embeddings also have different space costs, where space is defined as the amount of data accessed (i.e. retrieved from the structure) in order to
satisfy the resolution of the respective fURI.

.Amortized Costs in Terms of Space
[.small][.center]
[%header,width=50%,cols="l2,c1,c1,c1"]
|===
| embedding              | single-element | row-access    | column-access
| [.red]#entry#          | \$O(1)\$       | \$O(n)\$      | \$O(m)\$
| [.red]#row#            | \$O(n)\$       | \$O(n)\$      | \$O(n+m)\$
| [.red]#row_column#     | \$O(n+m)\$     | \$O(n+m)\$    | \$O(n+m)\$
|===


[source,mmadt]
----
                                    [a=>[b,c]]
                                       [‚ñ†]
          [‚ñ†]                         /   \
                              [b=>c][‚ñ†]   [‚ñ†][d=>e]

   [a=>[b=>c,d=>e]]]            [a=>[b=>c,d=>e]]]
           ^                            ^
           |                            |
           x                            x/

----

++++

<!-- ######################################################################################################## ############################################################################################################# ########################################### SCHEDULER ####################################################### ############################################################################################################# ############################################################################################################# -->

++++

=== The Scheduler Process




=== A FhatOS Console

.FhatOS Console
****
The [fuchsia]#F#‚Äã[lime]*h*‚Äã[red]*a*‚Äã[aqua]#T#‚Äã[yellow]*o*‚Äã[blue]*S*‚Äã Console is a composite of 3 other actors:

. The `Terminal` (`/sys/io/terminal/`) provides thread-safe access to hardware I/O.
. The `Parser` (`/sys/lang/parser/`) converts string input to bytecode output.
. The `Processor` (`/sys/lang/processor/`) executes bytecode.
****

=== fURI and MQTT

https://en.wikipedia.org/wiki/MQTT[MQTT] is a publish/subscribe message passing protocol that has found extensive usage in embedded systems.
Hierarchically specified _topics_ can be **subscribed** and **published** to.
In MQTT, there is no direct communication between actors, though such behavior can be simulated if an actor's mailbox is a unique topic.
[fuchsia]#f#‚Äã[yellow]*h*‚Äã[blue]*A*‚Äã[lime]*T*‚Äã[red]#o#‚Äã[aqua]*S*‚Äã leverages MQTT, but from the vantage point of URIs instead of topics with message routing being location-aware.
There exist three MQTT routers:

. `MonadRouter`: An MQTT router scoped to an active monad (**thread**) processing a monoid (**program**).
. `MonoidRouter`: An MQTT router scoped to a monoid (**program**).
. `HostRouter`: An MQTT router scoped to the current host (**machine**).
. `ClusterRouter`: An MQTT router scoped to the current intranet (**cluster**).
. `GlobalRouter` : An MQTT router scoped to the Internet.
. `MetaRouter`: An MQTT router dynamically scoped to other routers based on fURI endpoints.

.fURI Router Scope Patterns
****
TIP: The more `/` in the fURI prefix, the more distributed the fURI repeat.
* `abc` monad scoped fURI.
* `~/abc` monoid scoped fURI ("home directory" of executing program).
* `/abc` host scoped fURI (rooted at `localhost`).
* `//abc` cluster scoped fURI (hosted on the intranet).
* `//fhatos.org/abc` globally scoped fURI (hosted on the internet)
****

.Monoid power method
[latexmath]
++++

M = aM

++++

++++

<!-- üêñ ./main_runner.out
{1,2,3}
{1,2,3}.plus(10)
{1,2,3}.plus(_)
{1,2,3}.plus(plus(_)) -->

++++

[source,mmadt,subs="-replacements"]
----
fhatos> {1,2,3}
==>1
==>2
==>3
fhatos> {1,2,3}.plus(10)
==>11
==>12
==>13
fhatos> {1,2,3}.plus(_)
==>2
==>4
==>6
fhatos> {1,2,3}.plus(plus(_))
==>3
==>6
==>9
----

++++

<!-- üêì -->

++++

== FhatOS Modules

=== Kernel Modules

==== mmADT Module (mmadt)

===== Type Module (mmadt:type)

===== Parser Module (mmadt:parser)

==== Scheduler Module (scheduler)

==== Router Module (router)

=== Core Modules

==== Pin Modules

===== GPIO (gpio)

Hardware devices with digital general purpose input/output (GPIO) can be manipulated with `/fos/io/gpio`.

===== PWM (pwm)

Pins that support pulse-wave modulation can be manipulated with `/fos/io/pwm`.

===== i2c (i2c)

Two wire access

==== FileSystem Module (fs)

==== Terminal Module (terminal)

==== REPL Module (repl)

==== Logging Module (log)

=== Embedded Systems Modules

==== Sensors

==== Actuators

== Reference

=== mm-ADT Core Instructions

==== as `[_]`

==== block `|`

==== is

==== plus

++++

<!-- üêñ ./main_runner.out "true.plus(false)" "1.plus(2)" "'a'.plus('b')" -->

++++

[source,mmadt,subs="-replacements"]
----
fhatos> true.plus(false)
==>true
fhatos> 1.plus(2)
==>3
fhatos> 'a'.plus('b')
==>'ab'
----

++++

<!-- üêì -->

++++

==== mult

==== mod

==== lift `^`

==== drop `v`

==== split `-<`

==== each `=`

==== within `\_/ \_`

==== merge `>-`

==== from `*`

==== to `\->`

==== get `@`

==== pass `-\->`

==== match `~`

++++

<!-- üêñ ./main_runner.out "[a=>2].match([a=>3])" "[a=>2].match([a=>_])" -->

++++

[source,mmadt,subs="-replacements"]
----
fhatos> [a=>2].match([a=>3])
[ERROR] [/mmadt/rec] match inst unresolved 
	         lhs id      inst id    resolve obj
	  ->[/mmadt/rec] match => noobj
	 -->[/mmadt/rec] match => noobj
	--->[          ] match => noobj
fhatos> [a=>2].match([a=>_])
[ERROR] [/mmadt/rec] match inst unresolved 
	         lhs id      inst id    resolve obj
	  ->[/mmadt/rec] match => noobj
	 -->[/mmadt/rec] match => noobj
	--->[          ] match => noobj
----

++++

<!-- üêì -->

++++

==== eq

==== neq

==== gt

==== lt

==== gte

==== lte

== FhatOS Types

=== Process Types

==== thread

==== fiber

==== coroutine

=== PubSub Types

==== sub

[source,mmadt]
----
sub[[:source=>_, :pattern=>_, :on_recv=>bcode[_]]]
----

==== msg

[source,mmadt]
----
msg[[:target=>uri[_], :payload=>_, :retain=>bool[_]]]
----

:imagesdir: ./images
:favicon: {imagesdir}/fhatos-logo-small.png
:author: Dogturd Stynx
:email: dogturd.stynx@fhatos.org
:revnumber: 0.1
:tabsize: 2
:icons: font
:stem: latexmath
:source-highlighter: highlight.js
:highlightjsdir: ./highlight
:highlightjs-languages: mmadt,bash,cpp
:stylesheet: ./css/fhatos.css
:data-uri:
:toc: left
:toclevels: 4
:license-url: https://www.gnu.org/licenses/agpl-3.0.html
:license-title: AGPLv3
:docinfo: shared

= FhatOS: A Distributed Operating System for Embedded Systems (v{revnumber})

image:fhatos-logo.png[width=140,float=left] **FhatOS** (pronounced _fat-ahs_) is a https://en.wikipedia.org/wiki/Distributed_operating_system[distributed operating system] for https://en.wikipedia.org/wiki/ESP8266[ESP8266] and https://en.wikipedia.org/wiki/ESP32[ESP32] processors with support for sandboxed deployments on Linux and MacOSX systems.
All FhatOS resources, from individual datum, complex structures, files, and processes exist within a single https://en.wikipedia.org/wiki/Uniform_Resource_Identifier[URI] address repeat called **furi** (pronounced "fury" or "fhat URI").
Processes communicate via a publish-subscribe message passing protocol that rides atop the https://en.wikipedia.org/wiki/MQTT[MQTT] pubsub protocol while supporting various levels of access from thread local, to machine local and ultimately, globally via cluster remote.

image:github-icon.png[width=25,float=left,link=https://github.com/phaseshift-studio/fhatos] **source code** +

== FhatOS Features

. A hardware-agnostic https://en.wikipedia.org/wiki/Scheduling_(computing)[scheduler] for multi-tasking (https://en.wikipedia.org/wiki/Cooperative_multitasking[cooperative]) and multi-threading (https://en.wikipedia.org/wiki/Preemption_(computing)[premptive]) https://en.wikipedia.org/wiki/Monoid_(category_theory)[monoids].
. An https://en.wikipedia.org/wiki/Actor_model[actor-oriented] https://en.wikipedia.org/wiki/Message_passing[message passing] communication infrastructure.
. A memory architecture founded on a layered https://en.wikipedia.org/wiki/Uniform_Resource_Identifier[URI]-addressed https://en.wikipedia.org/wiki/Tuple_space[tuple repeat].
. A hardware agnostic https://en.wikipedia.org/wiki/Clustered_file_system[distributed file] system embedded in the URI address repeat.
. A programming language for defining monoids to control swarms of distributed https://en.wikipedia.org/wiki/Monad_(functional_programming)[monads].
. A https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop[REPL] environment for writing and deploying monoids in real-time.
. Runs in a https://en.wikipedia.org/wiki/Sandbox_(computer_security)[sandboxed] form on Linux and MacOS system.
. A https://en.wikipedia.org/wiki/Bootloader[bootloader] driven by a single https://en.wikipedia.org//wiki/YAML[YAML] file.

== FhatOS Boot Loader

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/boot_runner.out -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt,subs="verbatim"]
----
            PhaseShift Studio Presents 
 <`--'>____  ______ __  __  ______  ______  ______  ______ 
 /. .  `'  \/\  ___/\ \_\ \/\  __ \/\__  _\/\  __ \/\  ___\ 
(`')  ,     @ \  __\ \  __ \ \  __ \/_/\ \/\ \ \_\ \ \___  \ 
 `-._,     / \ \_\  \ \_\ \_\ \_\ \_\ \ \_\ \ \_____\/\_____\ 
    )-)_/-(>  \/_/   \/_/\/_/\/_/\/_/  \/_/  \/_____/\/_____/ 
                                   A Dogturd Stynx Production 
    fhatos-0.1-alpha > linux-6.8.0-48-generic > x86_64
    Use noobj for noobj
[INFO]  [/sys/scheduler] scheduler started
[INFO]  [/sys/router] router started
[INFO]  [/sys/router] /sys/# heap attached
[INFO]  [/sys/router] /sys/scheduler obj loaded
[INFO]  [/sys/router] /import/# heap attached
[INFO]  [/sys/router] /type/# heap attached
[INFO]  [/sys/router] /type/ obj loaded
[INFO]  [/sys/router] /io/# heap attached
[INFO]  [/type/] [/type/rec/terminal] type defined
[INFO]  [/sys/router] /io/terminal obj loaded
[INFO]  [/type/] [/import/io/console] type defined
[INFO]  [/sys/router] +/# heap attached
[INFO]  [/sys/router] /io/parser obj loaded
[INFO]  [//driver/#] 
    broker address: mqtt://localhost
    client name   : fhatos_native
    will topic    : <none>
    will message  : <none>
    will qos      : <none>
    will retain   : <none>
[INFO]  [/sys/router] //driver/# mqtt attached
[INFO]  [/sys/router] /driver/# heap attached
[INFO]  [/type/] [/type/rec/driver/gpio/arduino/furi] type defined
[INFO]  [/sys/router] /console/# heap attached
[INFO]  [/sys/scheduler] [/console] process spawned
----
++++
<!-- OUTPUT:END -->
++++

=== Booting on Linux/Unix/Mac

=== Booting on ESP32

=== Booting on ESP8266

=== Booting on RaspberryPi

== FhatOS Architecture

FhatOS is organized along a design principle that undersands computing as being composed of 3 fundamental phenomena: **process** (time), **structure** (repeat), and **language** (perspective). The core FhatOS kernel (typically denoted `/sys/`) can be divided along these lines as exemplified by the following resources:

. `/sys/scheduler/` (**process**): provides all thread, fiber, and coroutine processes compute time on the underlying hardware processor.
. `/sys/router/` (**structure**) : maintains the multi-level tuple repeat used for storing and retrieving resources in the fURI address repeat.
. `/sys/mmadt/` (**language**): exposes parsing, type management, and caching functionality to all mm-ADT progams.

All resources off the specified kernel fURIs can be interacted with, but can not be shutdown. That is, `/sys/# -> noobj` yields an error. Without these resources, FhatOS will not function propertly.

User resources are typicaly structured as below:

. `/io/`: location of input/output devices such as terminal, files, etc.
. `/home/`: location of all user data and programs.
. `/driver/`: location of all external device drivers.
. `/log/`: location of all log output.
. `/ext/`: location of various mm-ADT extensions.

The following subsections will provide a short overview of the aforementioned resources in reverse order: mm-ADT, router, and then scheduler.

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "/console/config/nest -> true" "*/sys/scheduler" "*/sys/scheduler/process/0" "**/sys/scheduler/process/0" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> */sys/scheduler
[ERROR] bool[true] accessed as int
fhatos> */sys/scheduler/process/0
[ERROR] bool[true] accessed as int
fhatos> **/sys/scheduler/process/0
[ERROR] bool[true] accessed as int
----
++++
<!-- OUTPUT:END -->
++++

=== The mm-ADT Language

FhatOS software can be written in C/C\++ or mm-ADT (**multi-model abstract data type**). mm-ADT is a cluster-oriented programming language and virtual machine founded on 5 **mono-types** (`bool`, `int`, `real`, `uri`, and `str`) and 2 **poly-types** (`lst` and `rec`). The general structure of an instance of a type is:

[source,mmadt]
----
type_id[value]@value_id
----

* `type_id`: the fURI referring to an `obj` type definition.
* `value`: the underlying raw data of the `obj`.
* `location` (optional): the fURI referring to the location of the `obj`.

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "/type/int/nat -> |is(gt(0))" "x -> nat[12]" "@x.inspect()" "@x" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> /type/int/nat -> |is(gt(0))
===>is(gt(0))
fhatos> x -> nat[12]
===>nat[12]
fhatos> @x.inspect()
=>[
===>type_id=>/type/int/nat
===>type=>is(gt(0))
===>value_id=>x
===>value=>12
===>encoding=>int32_t
=>]
fhatos> @x
===>nat[12]@x
----
++++
<!-- OUTPUT:END -->
++++

==== Types

mm-ADT is composed of two fundamental types: `obj` and `noobj`. Within `obj`, there are 7 base types. These types and their fURIs are:

. `/type/bool`: The set of binary values `true` and `false`.
. `/type/int`: The set of 64-bit integers between `-46666666` and `4777777`.
. `/type/real`: The set of 64-bit floating point values between `-...` and `....`.
. `/type/str`: The infinite set of all character sequences.
. `/type/uri`: The infinite set of all Uniform Resource Identifiers (URIs).
. `/type/lst`: An ordered container of zero or more `objs`.
. `/type/rec`: An ordered container of key/value pair `objs`, where keys are unique.

.Base Type Sugar
****
TIP: Given the frequency of use of base types, specifying the type is not necessary as, given the value, the base type can be deduced.
++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "/type/int/[6]" "int[6]" "6" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> /type/int/[6]
===>6
fhatos> int[6]
===>6
fhatos> 6
===>6
----
++++
<!-- OUTPUT:END -->
++++
****


Examples of the aforementioned types are provided below.

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "true" "42" "-64.02567" "'the fhatty'" "mmadt://a/furi" "[-1,'fhat',[0,1]]" "[a=>1,b=>'2',c=>3.0]" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> true
===>true
fhatos> 42
===>42
fhatos> -64.02567
===>-64.025673
fhatos> 'the fhatty'
===>'the fhatty'
fhatos> mmadt://a/furi
===>mmadt://a/furi
fhatos> [-1,'fhat',[0,1]]
=>[
===>-1
===>'fhat'
===>
====>[0,1]
=>]
fhatos> [a=>1,b=>'2',c=>3.0]
=>[
===>a=>1
===>b=>'2'
===>c=>3.000000
=>]
----
++++
<!-- OUTPUT:END -->
++++


==== Expression Structure

[source]
----
obj.f(obj).f(obj).f(obj)
----



===== Bytecode and Instruction Types

===== User Defined Types

mm-ADT is a structurally typed language, whereby if an `obj` *A* __matches__ `obj` *B*, then *A* is _a type of_ *B*. An `obj` type is a simply an mm-ADT program that verifies instances of the type. For instance, if a natural number stem:[\mathbb{N}] is any non-negative number, then natural numbers are a subset (or refinement) of `int`.

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "/type/int/nat -> |is(gt(0))" "nat[6]" "nat[-6]" "nat[3].plus(2)" "nat[3].mult(-2)" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> /type/int/nat -> |is(gt(0))
===>is(gt(0))
fhatos> nat[6]
===>nat[6]
fhatos> nat[-6]
[ERROR] [/type/] -6 is not a /type/int/nat[is(gt(0))]
fhatos> nat[3].plus(2)
===>nat[5]
fhatos> nat[3].mult(-2)
[ERROR] [/type/] -6 is not a /type/int/nat[is(gt(0))]
		thrown when applying nat[3] => mult(-2)
----
++++
<!-- OUTPUT:END -->
++++

===== Process Types

A simple mm-ADT program is defined below.
The program is a specialization of the poly-type `rec` called `thread`, where `thread` is abstractly defined as

[source,mmadt]
----
thread[[:setup => __]
        :loop  => __]]
----

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "abc -> |thread[[:setup=>x->0,:loop=>from(x).plus(1).to(x).print(*x).is(gt(10)).abc/:halt.to_inv(1,false),:stop=>print('done')]]" "/sys/scheduler/:spawn.to_inv(@abc,false)" -->
<!-- CODE:END -->
++++

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "/type/int/nat -> |is(gt(0))" "/type/rec/person -> |[name=>str[_],age=>nat[_]]" "person[[name=>'fhatty',age=>0]]" "person[[name=>'fhatty',age=>1]]" -->
<!-- CODE:END -->
++++

The `thread` object is published to the fURI endpoint `esp32@127.0.0.1/scheduler/threads/logger`.
The scheduler spawns the program on an individual `thread` accessible via the target fURI.
Once spawned, the `setup` function prints the thread's id and halts.

=== The Router Structure

The FhatOS router is the mediator of all structures: ensuring no two structures have overlapping patterns, migrating reads/writes between processes.

[cols="7,8"]
|===
a|
++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "*x" "*y" "y -> 12" "x -> y" "*x" "**x" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> *x
fhatos> *y
fhatos> y -> 12
===>12
fhatos> x -> y
===>y
fhatos> *x
===>y
fhatos> **x
===>12
----
++++
<!-- OUTPUT:END -->
++++
a|
[source,mmadt]
----
   [■]                         [■]
  /   \                       /   \
 /     \                     /     \
[■]    [■]                  [■]    [■]
      /   \                       /   \
     /     \                     /     \
   [■]     [y]@x ------------> [12]@y  [■]
----
`y` references `12`. `x` references `y`. a double dereferences jumps the monad from `x` to `y` to `12`.
a|
++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "x -> 12" "*x.plus(10)" "*x" "@x" "@x.plus(10)" "*x"  -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> x -> 12
===>12
fhatos> *x.plus(10)
===>22
fhatos> *x
===>12
fhatos> @x
===>12@x
fhatos> @x.plus(10)
===>22@x
fhatos> *x
===>22
----
++++
<!-- OUTPUT:END -->
++++
a|
[source,mmadt]
----
   [■]                          [■]
  /   \                        /   \
 /     \                      /     \
[■]    [■]                   [■]    [■]
      /   \                           \
     /     \         @x.plus(10)       \
   [■]     [12]@x ------------------> [22]@x
----
`12` is written to `x`. `10` is added to `x` (*pass by value* `*`). `x` still stores `12`. `10` is added to `x` (**pass by reference** `@`). `x` now stores `22`.
a|
++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "x?sub -> \|to(y)" "*x?sub" "*y" "x->12" "*y" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> x?sub -> \|to(y)
===>to(y,true)
fhatos> *x?sub
=>sub[
===>:source=>/console
===>:pattern=>x
===>:on_recv=>to(y,true)
=>]
fhatos> *y
fhatos> x->12
===>12
fhatos> *y
===>12
----
++++
<!-- OUTPUT:END -->
++++
a|
[source,mmadt]
----
   [■]                          [■]
  /   \                        /   \
 /     \                      /     \
[■]    [■]        [sub]     [■]     [■]
      /   \      .     .   /   \
     /     \    .       . /     \
   [■]     [12]@x       [12]@y  [■]
----
subscribes to `x` with bcode of the form \$f(x) -> y\$. `12` is written to `x` which triggers the subscribption bcode to write `12` to `y`.
|===

=== The Scheduler Process

=== A FhatOS Console

.FhatOS Console
****
The FhatOS Console is a composite of 3 other actors:

. The `Terminal` (`/sys/io/terminal/`) provides thread-safe access to hardware I/O.
. The `Parser` (`/sys/lang/parser/`) converts string input to bytecode output.
. The `Processor` (`/sys/lang/processor/`) executes bytecode.
****

=== fURI and MQTT

https://en.wikipedia.org/wiki/MQTT[MQTT] is a publish/subscribe message passing protocol that has found extensive usage in embedded systems.
Hierarchically specified _topics_ can be **subscribed** and **published** to.
In MQTT, there is no direct communication between actors, though such behavior can be simulated if an actor's mailbox is a unique topic.
FhatOS leverages MQTT, but from the vantage point of URIs instead of topics with message routing being location-aware.
There exist three MQTT routers:

. `MonadRouter`: An MQTT router scoped to an active monad (**thread**) processing a monoid (**program**).
. `MonoidRouter`: An MQTT router scoped to a monoid (**program**).
. `HostRouter`: An MQTT router scoped to the current host (**machine**).
. `ClusterRouter`: An MQTT router scoped to the current intranet (**cluster**).
. `GlobalRouter` : An MQTT router scoped to the Internet.
. `MetaRouter`: An MQTT router dynamically scoped to other routers based on fURI endpoints.

.fURI Router Scope Patterns
****
TIP: The more `/` in the fURI prefix, the more distributed the fURI repeat.

* `abc` monad scoped fURI.
* `~/abc` monoid scoped fURI ("home directory" of executing program).
* `/abc` host scoped fURI (rooted at `localhost`).
* `//abc` cluster scoped fURI (hosted on the intranet).
* `//fhatos.org/abc` globally scoped fURI (hosted on the internet)
****

.Monoid power method
[latexmath]
++++
M = aM
++++

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "{1,2,3}" "{1,2,3}.plus(10)" "{1,2,3}.plus(_)" "{1,2,3}.plus(plus(_))" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> {1,2,3}
===>1
===>2
===>3
fhatos> {1,2,3}.plus(10)
===>11
===>12
===>13
fhatos> {1,2,3}.plus(_)
===>2
===>4
===>6
fhatos> {1,2,3}.plus(plus(_))
===>3
===>6
===>9
----
++++
<!-- OUTPUT:END -->
++++

== FhatOS Modules

=== Kernel Modules

==== mmADT Module (mmadt)

===== Type Module (mmadt:type)

===== Parser Module (mmadt:parser)

==== Scheduler Module (scheduler)

==== Router Module (router)

=== Core Modules

==== FileSystem Module (fs)

==== Terminal Module (terminal)

==== REPL Module (repl)


==== Logging Module (log)

=== Embedded Systems Modules

==== Sensors

==== Actuators

== Reference

=== mm-ADT Core Instructions

==== as `[_]`

==== block `|`

==== is
==== plus

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "true.plus(false)" "1.plus(2)" "'a'.plus('b')" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> true.plus(false)
===>true
fhatos> 1.plus(2)
===>3
fhatos> 'a'.plus('b')
===>'ab'
----
++++
<!-- OUTPUT:END -->
++++

==== mult

==== mod

==== lift `^`

==== drop `v`

==== split `-<`

==== each `=`

==== within `\_/ \_`

==== merge `>-`

==== from `*`

==== to `\->`

==== get `@`

==== pass `-\->`
==== match `~`

++++
<!-- CODE:BASH:START -->
<!-- ./docs/build/main_runner.out "[a=>2].match([a=>3])" "[a=>2].match([a=>_])" -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
++++
[source,mmadt]
----
fhatos> [a=>2].match([a=>3])
===>false
fhatos> [a=>2].match([a=>_])
===>true
----
++++
<!-- OUTPUT:END -->
++++

==== eq

==== neq

==== gt

==== lt

==== gte

==== lte

== FhatOS Types

=== Process Types

==== thread

==== fiber

==== coroutine

=== PubSub Types
==== sub

[source,mmadt]
----
sub[[:source=>_, :pattern=>_, :on_recv=>bcode[_]]]
----

==== msg

[source,mmadt]
----
msg[[:target=>uri[_], :payload=>_, :retain=>bool[_]]]
----

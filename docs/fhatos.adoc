:imagesdir: ./images
:favicon: {imagesdir}/fhatos-logo-small.png
:copyright: PhaseShift Studio
:author: üí© Dogturd Stynx
:email: dogturd.stynx@fhatos.org
:revnumber: 0.1
:tabsize: 2
:icons: font
:icon-set: fas
:stem: latexmath
:source-highlighter: highlight.js
:highlightjsdir: ./highlight
:highlightjs-languages: mmadt, bash
:stylesheet: ./css/fhatos.css
:data-uri:
:toc-title: üêñ FhatOS
:toc: left
:toclevels: 4
:license-url: https://www.gnu.org/licenses/agpl-3.0.html
:license-title: AGPLv3
:lang: en
:docinfo: shared
:max-width: 75%
:app-name: FhatOS
:version-label: 0.1-alpha
:docname: FhatOS Documentation
:doctitle: FhatOS: A Distributed Operating System for Embedded Systems

= FhatOS: A Distributed Operating System for Embedded Systems (v{revnumber})

++++
<script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css"/>
++++

image:fhatos-logo.png[width=140,float=left] **FhatOS** (pronounced _fat-ahs_) is a
https://en.wikipedia.org/wiki/Distributed_operating_system[distributed operating system] for
https://en.wikipedia.org/wiki/ESP8266[ESP8266], https://en.wikipedia.org/wiki/ESP32[ESP32],
https://en.wikipedia.org/wiki/Raspberry_Pi[Raspberry PI], and similar fabrications.
Moreover, sandboxed deployments on Linux and MacOSX systems offer the cluster large memory/storage space and processor speed.
All [blue]*f*‚Äã[red]#H#‚Äã[lime]*A*‚Äã[yellow]#T#‚Äã[aqua]#O#‚Äã[fuchsia]#S#‚Äã resources, from individual datum, complex data structures, files, and threads exist within a single
https://en.wikipedia.org/wiki/Uniform_Resource_Identifier[URI] address space called **furi**
(pronounced "fury" or "fhat URI") -- a subset of the common URI space.
Programs are written in http://mmadt.org[mm-ADT] or https://en.wikipedia.org/wiki/C_(programming_language)[C] / https://en.wikipedia.org/wiki/C%2B%2B[C++]
and communicate with one another via storage structures that maintain subsets of the fURI space.
In general, [red]*f*‚Äã[lime]#H#‚Äã[fuchsia]#A#‚Äã[blue]#T#‚Äã[yellow]*O*‚Äã[aqua]#S#‚Äã provides a convenient medium for coordinating a heterogeneous collection of hardware processors and their peripheries.

https://github.com/phaseshift-studio/fhatos[üêô **source code**]

== FhatOS Features

. A hardware-agnostic https://en.wikipedia.org/wiki/Scheduling_(computing)[scheduler] for executing multi-threaded https://en.wikipedia.org/wiki/Monoid_(category_theory)[monoids].
. A memory architecture enabling the integration of various storage mediums within a single https://en.wikipedia.org/wiki/Uniform_Resource_Identifier[URI] https://en.wikipedia.org/wiki/Tuple_space[address space].
. A https://en.wikipedia.org/wiki/Clustered_file_system[distributed file] system embedded in the URI address space.
. A programming language for https://en.wikipedia.org/wiki/Fluent_interface[fluently] creating https://en.wikipedia.org/wiki/Monoid[monoids] to control a distributed swarm of https://en.wikipedia.org/wiki/Monad_(functional_programming)[monads].
. A https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop[REPL] environment for writing and deploying monoids in real-time.
. A collection common embedded systems protocols https://en.wikipedia.org/wiki/General-purpose_input/output[GPIO], https://en.wikipedia.org/wiki/Pulse-width_modulation[PWM], https://en.wikipedia.org/wiki/I%C2%B2C[I2C], and https://en.wikipedia.org/wiki/Serial_Peripheral_Interface[SPI].
. A suite of common sensor, actuator, and UI modules.
. A https://en.wikipedia.org/wiki/Sandbox_(computer_security)[sandboxed] distribution enabling Linux and MacOS systems to participate in the cluster.
. A monoidal https://en.wikipedia.org/wiki/Bootloader[bootloader] with support for https://en.wikipedia.org/wiki/Over-the-air_update[OTA] firmware updates.

== FhatOS Boot Loader

The following output is from a Linux boot of [red]#F#‚Äã[lime]*H*‚Äã[fuchsia]#A#‚Äã[yellow]*t*‚Äã[aqua]#O#‚Äã[blue]#S#‚Äã.
The purpose of this documentation is to explain the mechanics of the boot process and beyond.

[source,bash]
----
$ fhatos --boot:config=../conf/boot-loader.obj
----

++++
<!-- üêñ ./boot_runner.out -->
++++

[source,mmadt]
----
----

++++
<!-- üêì -->
++++

=== Booting on Linux/Unix/Mac

=== Booting on ESP32

=== Booting on ESP8266

=== Booting on RaspberryPi

== FhatOS Architecture

====
TIP: The "animal sticker" images used throughout the documentation are of the chickens, ducks, and dogs that have or are currently living on the FhatFarm.
Many of the code examples attempt to highlight their unique, individual personalities.
To learn their names, hover on their image.
====

image:cooties.png[width=140,float=left,title=cooties] [yellow]*f*‚Äã[red]*h*‚Äã[fuchsia]#a#‚Äã[aqua]#t#‚Äã[blue]*O*‚Äã[lime]*S*‚Äã is designed according to the undertsanding that computing is composed of 3 fundamental phenomena: **structure** (space), **process** (time), and **language** (perspective).
The core [yellow]*f*‚Äã[lime]#H#‚Äã[blue]*a*‚Äã[fuchsia]#t#‚Äã[red]*O*‚Äã[aqua]*S*‚Äã kernel provides the following resources.

. `/sys/scheduler` (**process**): provides all https://en.wikipedia.org/wiki/Thread_(computing)[thread], fiber, and coroutine processes compute time on the underlying hardware processor.
. `/sys/router` (**structure**) : maintains a distributed, partitioned https://en.wikipedia.org/wiki/Tuple_space[tuple space] used for storing and retrieving `objs` in the fURI address space.
. `/mmadt/` (**language**): enables source https://en.wikipedia.org/wiki/Parsing_expression_grammar[parsing], https://en.wikipedia.org/wiki/Type_system[type system] reasoning, and execution of mm-ADT programs.

The [lime]*F*‚Äã[yellow]*h*‚Äã[fuchsia]#a#‚Äã[red]*t*‚Äã[blue]#o#‚Äã[aqua]#s#‚Äã scheduler and router are accessed when their respective fURIs are https://en.wikipedia.org/wiki/Reference_(computer_science)[dereferenced] using the `from` instruction (sugar'd `*`).

++++
<!-- üêñ ./main_runner.out
*/sys/scheduler
*/sys/router
-->
++++

[source,mmadt]
----
fhatos> */sys/scheduler
=>[
==>thread=>[
===>/io/console
=>]
==>config=>[
===>def_stack_size=>8096
=>]
=>]@/sys/scheduler
fhatos> */sys/router
=>[
==>structure=>[
===>/sys/#
===>/mnt/#
===>/boot/#
===>/fos/#
===>/mmadt/#
===>/io/#
===>+/#
===>/disk/#
===>/shared/#
===>/bus/#
=>]
==>frame=>[rec][_]
==>config=>[
===>resolve=>[namespace=>[:=>/mmadt/,fos:=>/fos/],auto_prefix=>[,/mmadt/,/mmadt/ext/,/fos/,/fos/sys/,/fos/io/,/fos/sensor/,/fos/ui/,/fos/util/,/sys/],query=>[write=>[lock=>to_do]],default_config=>[query=>[write=>[sub=>noobj]]]]
=>]
==>query=>[
===>write=>[lock=>lock?obj{?}<=obj{?}()[cpp],sub=>sub?obj{?}<=obj()[cpp]]
=>]
=>]@/sys/router
----

++++
<!-- üêì -->
++++

Likewise, the mmADT language is embedded within the fURI address space. mm-ADT's encoding is large as it includes all mm-ADT types and instructions.
By dereferencing the `/mmadt` root with the wildcard extension `#`, a https://en.wikipedia.org/wiki/Reflective_programming[reflective] representation of the mm-ADT language is accessed.

+++ <details><summary> +++
üîó fURI encoding of the mmADT language
+++ </summary><div> +++

++++
<!-- üêñ ./main_runner.out "*/mmadt/#/" -->
++++

[source,mmadt]
----
fhatos> */mmadt/#/
=>[
==>/mmadt/a=>a(type=>_)[cpp]
==>/mmadt/apply=>apply?obj{*}<=obj(rhs=>noobj,args=>[=>])[cpp]
==>/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/at=>at?obj{?}<=obj{?}(from(0?var,noobj)[cpp])[cpp]
==>/mmadt/barrier=>barrier?objs{*}<=objs{*}(from(0?barrier_op,_)[cpp])[cpp]
==>/mmadt/bcode=>[bcode][_]
==>/mmadt/bcode/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/block=>block?obj<=obj{?}(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/bool=>[bool][_]
==>/mmadt/bool/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/div=>div(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/minus=>minus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/neg=>neg(from(0?self,_)[cpp])[cpp]
==>/mmadt/bool/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/count=>count?int<=objs{*}()[cpp]
==>/mmadt/div=>div(from(0?rhs,noobj)[cpp])
==>/mmadt/drop=>drop?obj{?}<=obj{?}(from(0?obj,_)[cpp])[cpp]
==>/mmadt/each=>each(from(0?poly,noobj)[cpp])
==>/mmadt/embed=>embed()[cpp]
==>/mmadt/end=>end?noobj{.}<=obj{*}()[cpp]
==>/mmadt/eq=>eq(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/error=>[error][_]
==>/mmadt/explain=>explain()[cpp]
==>/mmadt/ext/C=>C()[is(gte(-273.149994))]
==>/mmadt/ext/Ox=>Ox()[is(true)]
==>/mmadt/ext/char=>char()[merge(2).count().is(eq(1))]
==>/mmadt/ext/int16=>[int16][_]
==>/mmadt/ext/int32=>[int32][_]
==>/mmadt/ext/int8=>uint8()[is(gte(-127)).is(lte(128))]
==>/mmadt/ext/ms=>[int][_]
==>/mmadt/ext/nat=>nat()[is(gte(0))]
==>/mmadt/ext/prnt=>prnt()[is(gte(0.000000)).is(lte(100.000000))]
==>/mmadt/ext/sec=>[int][_]
==>/mmadt/ext/secret=>[str][_]
==>/mmadt/ext/secret/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/ext/uint8=>uint8()[is(gte(0)).is(lte(255))]
==>/mmadt/frame=>frame?rec<=obj{?}()[cpp]
==>/mmadt/from=>from?obj{?}<=obj{?}(from(0?uri,_)[cpp],from(1?default,noobj)[cpp])[cpp]
==>/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])
==>/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])
==>/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])
==>/mmadt/inst=>[inst][_]
==>/mmadt/inst/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/int=>[int][_]
==>/mmadt/int/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/div=>div(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/int/::/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/minus=>minus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/mod=>mod(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/int/::/mmadt/neg=>neg(from(0?self,_)[cpp])[cpp]
==>/mmadt/int/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/is=>is?obj{?}<=obj(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lock=>lock(user=>_)[cpp]
==>/mmadt/lshift=>lshift()
==>/mmadt/lst=>[lst][_]
==>/mmadt/lst/::/mmadt/div=>div(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/each=>each(from(0?lst,_)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/merge=>merge?objs{*}<=lst(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/minus=>minus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/split=>split(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/lst/::/mmadt/within=>within(from(0?code,noobj)[cpp])[cpp]
==>/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])
==>/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])
==>/mmadt/map=>map?obj{?}<=obj{?}(from(0?mapping,noobj)[cpp])[cpp]
==>/mmadt/merge=>merge?obj{?}<=obj(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/minus=>minus(from(0?rhs,noobj)[cpp])
==>/mmadt/mod=>mod(from(0?rhs,noobj)[cpp])
==>/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])
==>/mmadt/neg=>neg(from(0?self,_)[cpp])
==>/mmadt/neq=>neq(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/noobj=>[noobj][_]
==>/mmadt/obj=>[obj][_]
==>/mmadt/objs=>[objs][_]
==>/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])
==>/mmadt/print=>print?obj{?}<=obj{?}(from(0?to_print,_)[cpp])[cpp]
==>/mmadt/prod=>prod?obj<=objs{*}()[cpp]
==>/mmadt/real=>[real][_]
==>/mmadt/real/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/div=>div(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/real/::/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/minus=>minus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/real/::/mmadt/neg=>neg(from(0?self,_)[cpp])[cpp]
==>/mmadt/real/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/rec=>[rec][_]
==>/mmadt/rec/::/mmadt/div=>div(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/lshift=>lshift(level=>1)[cpp]
==>/mmadt/rec/::/mmadt/merge=>merge?objs{*}<=rec(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/minus=>minus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/rshift=>rshift(from(0?prefix,noobj)[cpp])[cpp]
==>/mmadt/rec/::/mmadt/within=>within(from(0?code,noobj)[cpp])[cpp]
==>/mmadt/ref=>ref?obj{?}<=obj{?}(from(0?id,noobj)[cpp],from(1?retain,true)[cpp])[cpp]
==>/mmadt/repeat=>repeat(from(0?code,noobj)[cpp],from(1?until,true)[cpp],from(2?emit,false)[cpp])[cpp]
==>/mmadt/rshift=>rshift()
==>/mmadt/split=>split(from(0?poly,noobj)[cpp])[cpp]
==>/mmadt/start=>start?objs{*}<=noobj{.}(from(0?starts,noobj)[cpp])[cpp]
==>/mmadt/str=>[str][_]
==>/mmadt/str/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/div=>div(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/str/::/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/merge=>merge?objs{*}<=str(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/str/::/mmadt/minus=>minus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/str/::/mmadt/within=>within(from(0?code,noobj)[cpp])[cpp]
==>/mmadt/sum=>sum?obj<=objs{*}()[cpp]
==>/mmadt/to=>to(from(0?uri,noobj)[cpp],from(1?retain,true)[cpp])[cpp]
==>/mmadt/type=>type?uri<=obj{?}(from(0?obj,_)[cpp])[cpp]
==>/mmadt/uri=>[uri][_]
==>/mmadt/uri/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/div=>div(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/gt=>gt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/gte=>gte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/inspect=>inspect(from(0?inspected,_)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/lshift=>lshift(level=>1)[cpp]
==>/mmadt/uri/::/mmadt/lt=>lt(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/lte=>lte(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/merge=>merge?objs{*}<=uri(from(0?count,2147483647)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/minus=>minus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/mult=>mult(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/plus=>plus(from(0?rhs,noobj)[cpp])[cpp]
==>/mmadt/uri/::/mmadt/rshift=>rshift(level=>1)[cpp]
==>/mmadt/within=>within(from(0?code,noobj)[cpp])
=>]
----

++++
<!-- üêì -->
++++

+++ </div></details> +++

The wildcard feature of the fURI scheme makes it possible to access instructions associated with a particular type.

++++
<!-- üêñ ./main_runner.out
*/mmadt/int/#
-->
++++

[source,mmadt]
----
fhatos> */mmadt/int/#
==>[int][[_]]
==>as?obj<=int(from?obj<=obj(0?type,noobj)[cpp])[cpp]
==>div?int<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
==>gt?bool<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
==>gte?bool<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
==>inspect?rec<=int(from?obj<=obj(0?inspected,_)[cpp])[cpp]
==>lt?bool<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
==>lte?bool<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
==>minus?int<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
==>mod?int<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
==>mult?int<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
==>neg?int<=int(from?obj<=obj(0?self,_)[cpp])[cpp]
==>plus?int<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
----

++++
<!-- üêì -->
++++

====
IMPORTANT: When an instruction body is displayed as `[cpp]`, it means that the instruction's implementation is written C++ and thus, no further introspection is possible from within mm-ADT.
When the instruction implementation is written in mm-ADT, the instruction body is displayed as `bcode` (a linear chain of `objs`).

[cols="2,2"]
|===

a|
++++
<!-- üêñ ./main_runner.out "*int::lt" -->
++++

[source,mmadt]
----
fhatos> *int::lt
==>lt?bool<=int(from?obj<=obj(0?rhs,noobj)[cpp])[cpp]
----

++++
<!-- üêì -->
++++

a|
++++
<!-- üêñ ./main_runner.out "*nat" -->
++++

[source,mmadt]
----
fhatos> *nat
==>nat?int<=int()[is(gte(0))]
----

++++
<!-- üêì -->
++++

|===
====

Shutting down [yellow]#f#‚Äã[fuchsia]#h#‚Äã[aqua]*A*‚Äã[lime]*T*‚Äã[red]*O*‚Äã[blue]#s#‚Äã is as simple as writing `noobj` to every `obj` that is fURI accessible to the local processor.

++++
<!-- üêñ ./main_runner.out
# -> noobj
-->
++++

[source,mmadt]
----
fhatos> # -> noobj
[ERROR] [/sys/router] # crosses multiple structures
[INFO]  [/sys/router] 1 bus(s) closing
[INFO]  [/sys/router] 1 dsm(s) closing
[INFO]  [/sys/router] 1 fs(s) closing
[INFO]  [/sys/router] 7 heap(s) closing
[INFO]  [/mmadt/rec] disconnecting from [mqtt://chibi.local:1883]
[INFO]  [/sys/router] router /sys/router stopped
[INFO]  [/sys/router] /sys/# heap detached
[INFO]  [/sys/router] /mnt/# heap detached
[INFO]  [/sys/router] /boot/# heap detached
[INFO]  [/sys/router] /fos/# heap detached
[INFO]  [/sys/router] /mmadt/# heap detached
[INFO]  [/sys/router] /io/# heap detached
[INFO]  [/sys/router] +/# heap detached
[INFO]  [/sys/router] /disk/# fs detached
[INFO]  [/sys/router] /shared/# dsm detached
[INFO]  [/sys/router] /bus/# bus detached
----

++++
<!-- üêì -->
++++

=== The mm-ADT Language

[aqua]#F#‚Äã[red]#h#‚Äã[lime]*a*‚Äã[blue]#t#‚Äã[yellow]*o*‚Äã[fuchsia]#s#‚Äã software can be written in C/C++ or mm-ADT (**multi-model abstract data type**). mm-ADT is a reflective, cluster-oriented programming language with a fluent syntax and an an underlying monoidal structure.
Every expression in mm-ADT yields an `obj` (object).

An `obj` is composed of a [.h]#type#, a [.h]#value#, a variable [.h]#frame#, and a storage location/[.h]#reference#.
The abstract syntax of a sugar-free `obj` is

[stem]
++++
\texttt{obj} := \texttt{type}(\texttt{frame})[\texttt{value}]@\texttt{ref}
++++

. The [.h]#type# is a fURI referring to an `obj` which determines whether the `obj` is of that type or not (_predicate_).
. The [.h]#frame# is a collection of fURI referenced `objs` that are accessible to the value of the `obj` (_arguments_).
. The [.h]#value# is a collection of `objs` denoting the form of the `obj` (_encoding_).
. The [.h]#reference# is a fURI denoting the durable location of the `obj` with the underlying storage structure (_memory address_).

The mmADT language and its evaluation by a processor will be explained via an exploration of these substructures;
to uncover the finer grained structures that lie within each.

==== The Type

==== The Frame

==== The Value

==== The Reference



An `obj` can be any one of

. 5 **mono-types** (`bool`, `int`, `real`, `str`, `uri`, and `noobj`),
. 2 **poly-types** (`lst` and `rec`), or
. 2 **code-types** (`inst` and `bcode`).

The mono and poly types are **structural**, while the code-types are **functional**.

==== Structural Types

The 7 structural types (5 mono-types and 2 poly-types) are described below.

. `/mmadt/noobj`: A singleton representing `null`.
. `/mmadt/bool`: The set of binary values `true` and `false`.
. `/mmadt/int`: The set of \$n\$-bit integers between \$-2^(n-1)\$ and \$2^(n-1)\$.
. `/mmadt/real`: The set of \$n\$-bit floating point values between `-...` and `....`.
. `/mmadt/str`: The infinite set of all UTF-8 character sequences.
. `/mmadt/uri`: The infinite set of all [red]#f#‚Äã[lime]#H#‚Äã[fuchsia]#A#‚Äã[blue]#T#‚Äã[yellow]*o*‚Äã[aqua]#s#‚Äã UTF-8 Uniform Resource Identifiers (fURIs).
. `/mmadt/lst`: An (un)ordered collection of zero or more `objs`.
. `/mmadt/rec`: An (un)ordered collection of key/value pair `objs`, where keys are unique.


===== Base Types

Given the frequency of use of base types, specifying the type is not necessary as, given the value, the base type can be deduced.

[tabs]
====
bool::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/bool[true]" "bool[true]" "true" -->
++++

[source,mmadt]
----
fhatos> /mmadt/bool[true]
==>true
fhatos> bool[true]
==>true
fhatos> true
==>true
----

++++
<!-- üêì -->
++++
--

int::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/int[6]" "int[6]" "6" -->
++++

[source,mmadt]
----
fhatos> /mmadt/int[6]
==>6
fhatos> int[6]
==>6
fhatos> 6
==>6
----

++++
<!-- üêì -->
++++
--

real::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/real[6.2]" "real[6.2]" "6.2" -->
++++

[source,mmadt]
----
fhatos> /mmadt/real[6.2]
==>6.2
fhatos> real[6.2]
==>6.2
fhatos> 6.2
==>6.2
----

++++
<!-- üêì -->
++++
--

str::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/str['cooties']" "str['cooties']" "'cooties'" -->
++++

[source,mmadt]
----
fhatos> /mmadt/str['cooties']
==>'cooties'
fhatos> str['cooties']
==>'cooties'
fhatos> 'cooties'
==>'cooties'
----

++++
<!-- üêì -->
++++
--

uri::
+
--
++++
<!-- üêñ ./main_runner.out "/mmadt/uri[/dog/curly]" "uri[/dog/curly]" "/dog/curly" -->
++++

[source,mmadt]
----
fhatos> /mmadt/uri[/dog/curly]
==>/dog/curly
fhatos> uri[/dog/curly]
==>/dog/curly
fhatos> /dog/curly
==>/dog/curly
----

++++
<!-- üêì -->
++++
--

lst::
+
--
++++
<!-- üêñ ./main_runner.out
[HIDDEN] /io/console/config/nest -> 0
/mmadt/lst[['a',2,true]]
lst[['a',2,true]]
['a',2,true]
-->
++++

[source,mmadt]
----
fhatos> /mmadt/lst[['a',2,true]]
==>['a',2,true]
fhatos> lst[['a',2,true]]
==>['a',2,true]
fhatos> ['a',2,true]
==>['a',2,true]
----

++++
<!-- üêì -->
++++
--

rec::
+
--
++++
<!-- üêñ ./main_runner.out
[HIDDEN] /io/console/config/nest->0
/mmadt/rec[[a=>6,b=>false]]
rec[[a=>6,b=>false]]
[a=>6,b=>false]
-->
++++

[source,mmadt]
----
fhatos> /mmadt/rec[[a=>6,b=>false]]
==>[a=>6,b=>false]
fhatos> rec[[a=>6,b=>false]]
==>[a=>6,b=>false]
fhatos> [a=>6,b=>false]
==>[a=>6,b=>false]
----

++++
<!-- üêì -->
++++
--

noobj::
+
--
++++
<!-- üêñ ./main_runner.out
/mmadt/noobj[]
noobj[]

-->
++++

[source,mmadt]
----
fhatos> /mmadt/noobj[]
fhatos> noobj[]
fhatos> 

----

++++
<!-- üêì -->
++++
--

====

Examples of the aforementioned types are provided below.

++++
<!-- üêñ ./main_runner.out "true" "42" "-64.02567" "'the fhatty'" "mmadt://a/furi" "[-1,'fhat',[0,1]]" "[a=>1,b=>'2',c=>3.0]" -->
++++

[source,mmadt]
----
fhatos> true
==>true
fhatos> 42
==>42
fhatos> -64.02567
==>-64.0257
fhatos> 'the fhatty'
==>'the fhatty'
fhatos> mmadt://a/furi
==>mmadt://a/furi
fhatos> [-1,'fhat',[0,1]]
=>[
===>-1
===>'fhat'
=>[
===>0
===>1
=>]
=>]
fhatos> [a=>1,b=>'2',c=>3.0]
=>[
==>a=>1
==>b=>'2'
==>c=>3.000000
=>]
----

++++
<!-- üêì -->
++++

.Controlling Base Value Bit Encoding
====
TIP: The bit-length of `int` and `real` can be specified at boot time via the boot-loader.
Other machines in the cluster with a different bit-length encodings can still be communicated with.
However, overflow is possible, but can be automatically checked using types in `/mmadt/ext/` such as:
`int8`, `int16`, `int32`.

[cols="5,5"]
|===

a|
++++
<!-- üêñ ./main_runner.out
int[6].inspect()
real[6.0].inspect()
-->
++++

[source,mmadt]
----
fhatos> int[6].inspect()
=>[
==>type=>[
===>id=>/mmadt/int
===>obj=>[int][_]
===>dom=>[id=>/mmadt/obj,coeff=>[1,1]]
===>rng=>[id=>/mmadt/int,coeff=>[1,1]]
=>]
==>value=>[
===>obj=>6
===>encoding=>int32_t
=>]
=>]
fhatos> real[6.0].inspect()
=>[
==>type=>[
===>id=>/mmadt/real
===>obj=>[real][_]
===>dom=>[id=>/mmadt/obj,coeff=>[1,1]]
===>rng=>[id=>/mmadt/real,coeff=>[1,1]]
=>]
==>value=>[
===>obj=>6.000000
===>encoding=>float_t
=>]
=>]
----

++++
<!-- üêì -->
++++

a|
++++
<!-- üêñ ./main_runner.out
/sys/router/config/resolve/auto_prefix -> /
  *(_) + \|[/mmadt/ext/]             --- <1>
a -> int8[126]                       --- <2>
@a + 1
@a + 1
@a + 1                               --- <3>
-->
++++

[source,mmadt]
----
fhatos> /sys/router/config/resolve/auto_prefix ->
          *(_) + \|[/mmadt/ext/]             // <1>
=>[
===>
===>/mmadt/
===>/mmadt/ext/
===>/fos/
===>/fos/sys/
===>/fos/io/
===>/fos/sensor/
===>/fos/ui/
===>/fos/util/
===>/sys/
===>/mmadt/ext/
=>]
fhatos> a -> int8[126]                       // <2>
==>int8[126]
fhatos> @a + 1
==>int8[127]@a
fhatos> @a + 1
==>int8[128]@a
fhatos> @a + 1                               // <3>
[ERROR] [/sys/type] 129@a is not a /mmadt/ext/int8 as defined by uint8()[is(gte(-127)).is(lte(128))]
	  thrown at inst int8[128]@a => plus(1)[cpp] [0=>1]
----

++++
<!-- üêì -->
++++

<1> Including `/mmadt/ext` `objs` in the router's automatic URI resolution.
<2> Constructing an `int` constrained to values from `-127` to `128`.
<3> Triggering `int8` type error by overflowing its numeric range.

|===
====

==== Functional Types

===== Sugar-Less mm-ADT

image:trill.png[width=150,float=right,title=trill] In the code example above, the expression to import `/mmadt/ext` is pretty intense looking, to say the least.

[source,mmadt]
----
/sys/router/config/resolve/auto_prefix ->  *(_) + \|[/mmadt/ext/]
----

The line above looks daunting because it contains numerous https://en.wikipedia.org/wiki/Syntactic_sugar[syntactic sugars].
Specifically, the binary and unary operators `->` (binary), `*` (unary), `_` (unary), `+` (binary), and `\|` (unary).
Each of these symbols ultimately parse down to an `inst`.
Each having that familiar functional form of `f(a,b,c,...)`.
For example, the _sugar free_ representation of the expression above is:

[cols="2,2"]
|===
a|
[source,mmadt]
----
start(</sys/router/config/resolve/auto_prefix>). // <1>
 ref(                                            // <2>
  from(_).                                       // <3>
  plus(                                          // <4>
    block(</mmadt/ext>)))                        // <5>
----
a|
<1> Evaluate the mm-ADT `bcode` with `uri[/sys/...]`.  `a ...`
<2> Use `uri[/sys/...]` as the address to store a value in an underlying structure. `a = ...`
<3> Fetch the value to store from the `uri[/sys/...]`. `a = get(a) ...`
<4> Add to the value stored at `uri[/sys/...]` to ... `a = get(a) + ...`.
<5> ... `uri[/mmadt/ext]`. `a = get(a) + b`.
|===

Given that `uri[/sys/router/config/resolve/auto_prefix]` resolves to a `lst` of `uris`,
`uri[/mmadt/ext]` is added that that `lst` and the updated `lst` is written back to
`uri[/sys/router/config/resolve/auto_prefix]`.

The one instruction that was not discussed above is `block` (sugar'd `|`).
This is perhaps the most useful instruction in the whole of mm-ADT and knowing how to uses is absoluately crucial to being competent with the language.
Moreover, when `block` is understood, so is a large portion of the language understood as well.
Before diving into `block`, it's important to first realize how instructions are evaluated.
For this, the fundamental, immutable instruction `apply` (sugar'd `.`) is the perfect place to start.

===== Inst Evaluation Mechanics

An mm-ADT `inst` is an https://en.wikipedia.org/wiki/Instruction_set_architecture#Instructions[instruction].
More generally, a https://en.wikipedia.org/wiki/Function_(computer_programming)[function].
More abstractly, a https://en.wikipedia.org/wiki/Function_(mathematics)[function].
Syntactically, an `inst` has the form:

[stem]
++++
\texttt{obj} := \texttt{type}(\texttt{frame})[\texttt{value}]@\texttt{ref}.
++++

Starting with the template above, components will be removed to highlight various `inst` forms and functions.

. latexmath:[\texttt{type}(\texttt{frame})[\texttt{value}\]@\texttt{ref}]: The complete form is a [.h]#referenced `inst`# and is used with coroutines.
. latexmath:[\texttt{type}(\texttt{frame})[\texttt{value}\]]: Without a reference location, the `obj` is a [.h]#standard `inst`#.
. latexmath:[\texttt{type}(\texttt{frame})[\]]: Without a reference or value, the `obj` is a [.h]#proto `inst`# resolved to a standard `inst` during compilation or runtime.
. latexmath:[\texttt{type}()[\]]: Without a reference, value, or frame, the `obj` is a [.h]#zero-arg proto `inst`# and is resolved during compilation or runtime.
. latexmath:[\texttt{type}]: Without a reference, value, frame, or respective tokens, the `obj` is an [.h]#`inst` reference# which can be dereferenced to yield the corresponding `inst` implementation.

[.center]
[source,mmadt]
----
type?rng{coeff}<=dom{coeff}(arg1, arg2, ...) [bcode]
----

[.center]
[stem]
++++
f(\mathcal{Dom}^{C} \times A_1 \times A_2 \times \ldots) \rightarrow \mathcal{Rng}^{C}
++++

The fURI query _type-specification_ is more advanced and requires an understanding of structure query processors.
As such, for now, realize an `inst` to have the form:

[.center]
[source,mmadt]
----
type(arg1, arg2, ...) [bcode]
----

[.center]
[stem]
++++
f(\mathcal{Obj}_{\texttt{dom}} \times A_1 \times A_2 \times \ldots) \rightarrow \mathcal{Obj}_{\texttt{rng}}
++++

In order to evaluate an `inst` an `obj` must be _applied_ to it.
Application is sugar'd `.`.

[.center]
[source,mmadt]
----
      inst(arg1, arg2, ...)
obj_d.inst(arg1, arg2, ...)
      inst(arg1, arg2, ...) => obj_r
----

When an `obj` is applied to an `inst`, the `obj` is called the _left-hand side_ `obj`.
This `obj` is the catalyst for a cascade of events that take place across the `inst` arguments and internal `bcode`.
The sequence of events are diagrammatically represented in the graphical explanation below where each line is a new timestep in the process.

[cols="6,9"]
|===
a|
[.center]
[source,mmadt]
----
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ     ‚îÇ
obj_d ‚îÄ‚îÄ‚îú‚îÄ> inst(arg1, arg2, ...)
        ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îå‚îÄ‚îò
        ‚îÇ               ‚îÇ   ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>[x.y.z]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> obj_r

----
a|
[.center]
[source,mmadt]
----
      inst(arg1, arg2, ...)             [x.y.z]             // <1>
obj_d.inst(arg1, arg2, ...)             [x.y.z]             // <2>
      inst(obj_d.arg1, obj_d.arg2, ...) [x.y.z]             // <3>
      inst(arg1_d, arg2_d, ...)         [obj_d.x.y.z]       // <4>
      inst(arg1_d, arg2_d, ...)         [x.y.z => obj_r]    // <5>
      inst(arg1, arg2, ...) => obj_r    [x.y.z]             // <6>
----
|===

<1> The `inst` with a collection of arguments and a `bcode` body called __inst_f__.
<2> A left-hand side `obj` is applied to the `inst`.
<3> The left-hand side `obj` is split across all arguments and applied to each.
<4> When all argument applications have completed, the left-hand side `obj` percolates through the `bcode`.
<5> The right-hand side `obj` produced by the `bcode` is the result of the application.
<6> The right-hand side `obj` becomes the input to the next `inst` in the large `bcode` expression (not shown).

The diagram states that the input `obj` is applied to each argument, the result of which are the actual arguments provided to the `inst`.
The `inst` is thus, generally defined as:

[.center]
[stem]
++++
\[
\begin{align*}
x \cdot f(args...) & \rightarrow y \\
f(x,x \cdot args...) & \rightarrow y \\
f(x,x \cdot args_1, x \cdot args_2, ...) & \rightarrow y \\
\end{align*}
\]
++++

What separates `inst` from other `poly` types such as `lst` and `rec` (discussed next) is that it mounts a https://en.wikipedia.org/wiki/Thread-local_storage[thread-local] structure on the router called a `fos:frame`.
The router supports a chain `fos:frame` structures and, in this way, `fos:frame` serves the purpose of a https://en.wikipedia.org/wiki/Call_stack[callstack], where the arguments of the `inst` can be dereferenced within the body of the `inst`.

++++
<!-- üêñ ./main_runner.out "34.make_bigger(a=>plus(10))[plus(*a)]" -->
++++

[source,mmadt]
----
fhatos> 34.make_bigger(a=>plus(10))[plus(*a)]
==>78
----

++++
<!-- üêì -->
++++

In the example above, `make_bigger` is defined "on the fly" (a "named lambda", if one chooses to see it as such) where the argument `a` can be dereferenced within the body of the `inst` `[ ... ]`.
The input to the body of the `inst` is, as can be expected, the left-hand side `int[34]`.

===== Generalized Poly Evaluation Mechanics

image:sopapilla.png[width=150,float=left,title=sopapilla]  The `fos:frame` is the only aspect of an `inst` that makes it unique because every `poly`-type supports the same internally recursive application of an left-hand side `obj`.
For example, see how the internal `objs` if a `lst` are effected by the application of an `obj` outside of the `lst`.

====== Lst Application

++++
<!-- üêñ ./main_runner.out
2.lst[[1,plus(2),mult(plus(3)),'a']]
-->
++++

[source,mmadt]
----
fhatos> 2.lst[[1,plus(2),mult(plus(3)),'a']]
=>[
===>1
===>4
===>10
===>'a'
=>]
----

++++
<!-- üêì -->
++++

Note that the application is recursive.
For example, `2.mult(plus(3))` is evaluated as follows:

[.center]
[stem]
++++
\[
\begin{align*}
2 \cdot \times(+(3)) & \rightarrow 10 \\
\times(2,2 \cdot +(3)) & \rightarrow 10 \\
\times(2, +(2,2 \cdot 3)) & \rightarrow 10 \\
\times(2, +(2,3)) & \rightarrow 10 \\
\times(2, 5) & \rightarrow 10 \\
10 & \rightarrow 10 \\
\end{align*}
\]
++++

====== Rec Application

A `rec` behaves in a similar manner to `lst` and `inst` when a left-hand side `obj` is applied to it.
However, what makes
`rec` interesting and useful beyond a data storage structure is it's _delayed evaluation semantics_ denoted by `=>`.

++++
<!-- üêñ ./main_runner.out
2.rec[[is(gt(2)) => plus(2), _ => 0]]
-->
++++

[source,mmadt]
----
fhatos> 2.rec[[is(gt(2)) => plus(2), _ => 0]]
=>[
==>2=>0
=>]
----

++++
<!-- üêì -->
++++

This feature of `rec` make it both a https://en.wikipedia.org/wiki/Data_structure[data structure] and a https://en.wikipedia.org/wiki/Control_flow[flow control structure] as once an `obj` has been applied to `rec`, the values of `rec` can be "drained".
For instance, `if` is implemented with a two entry `rec`, where one entry maps to `noobj`.

++++
<!-- üêñ ./main_runner.out
/io/console/config/nest -> 0                  --- <1>
{1,2,3}.[is(gt(2)) => _, _ => noobj]          --- <2>
{1,2,3}.[is(gt(2)) => _, _ => noobj]>-        --- <3>
-->
++++

[source,mmadt]
----
fhatos> /io/console/config/nest -> 0                  // <1>
==>0
fhatos> {1,2,3}.[is(gt(2)) => _, _ => noobj]          // <2>
==>[1=>noobj]
==>[2=>noobj]
==>[3=>_]
fhatos> {1,2,3}.[is(gt(2)) => _, _ => noobj]>-        // <3>
==>3
----

++++
<!-- üêì -->
++++

<1> Reducing the console's display depth for nested structures (purely aesthetic).
<2> A stream of `objs` is applied one-by-one to the `rec` yielding a new internally-applied `rec`.
<3> The internally-applied `rec` is "drained" via the `merge` `inst` (sugar'd `>-`).

In the above example, since `1` and `2` were mapped to `noobj`, they are effectively removed from the execution pipeline.
However, because `3` is `gt(2)`, it is mapped to `_` (its self).
Thus, when `>-` is applied to this `rec`, the result is
`{noobj,noobj,3}` which is equivalent to `{3}`.
In this way, `rec` is both a data structure and a flow control structure.

It's not difficult to realize how an "if"-`rec` generalizes to support the various plays on one of computing's most important concepts: https://en.wikipedia.org/wiki/Branch_(computer_science)[the branch].

[tabs]
====
if-else::
+
--
++++
<!-- üêñ ./main_runner.out
[HEADER] .if-else icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#If%E2%80%93then(%E2%80%93else),2x,role=blue]
{1,2,3}.[                  /
  ?>2 => mult(-1),   /
  _   => mult(100)]>-
-->
++++

.if-else icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#If%E2%80%93then(%E2%80%93else),2x,role=blue]
[source,mmadt]
----
fhatos> {1,2,3}.[                 
          ?>2 => mult(-1),  
          _   => mult(100)]>-
==>100
==>200
==>-3
----

++++
<!-- üêì -->
++++
--
switch::
+
--

++++
<!-- üêñ ./main_runner.out
[HEADER] .switch icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Case_and_switch_statements,2x,role=blue]
{1,2,3}.[             /
  ?=1 => mult(-1),    /
  ?=2 => mult(0),     /
  ?=3 => _]>-
-->
++++

.switch icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Case_and_switch_statements,2x,role=blue]
[source,mmadt]
----
fhatos> {1,2,3}.[            
          ?=1 => mult(-1),   
          ?=2 => mult(0),    
          ?=3 => _]>-
==>-1
==>0
==>3
----

++++
<!-- üêì -->
++++
--
guard::
+
--

++++
<!-- üêñ ./main_runner.out
[HEADER] .guard icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Guarded_conditionals,2x,role=blue]
{1,2,3}.[
-->
++++

.guard icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Guarded_conditionals,2x,role=blue]
[source,mmadt]
----
fhatos> {1,2,3}.[
==>1
==>2
==>3
----

++++
<!-- üêì -->
++++
--

pattern::
+
--

++++
<!-- üêñ ./main_runner.out
[HEADER] .pattern-match icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Pattern_matching,2x,role=blue]
--- todo
-->
++++

.pattern-match icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Pattern_matching,2x,role=blue]
[source,mmadt]
----
fhatos> --- todo
----

++++
<!-- üêì -->
++++
--

hash::
+
--
++++
<!-- üêñ ./main_runner.out
[HEADER] .conditional hash icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Hash-based_conditionals,2x,role=blue]
--- todo
-->
++++

.conditional hash icon:link[link=https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Hash-based_conditionals,2x,role=blue]
[source,mmadt]
----
fhatos> --- todo
----

++++
<!-- üêì -->
++++
--
====

====
NOTE: The `merge` (sugar'd `>-`) instruction has a correlate: `split` (sugar'd `-<`).
The way to think of these two instructions is that they either branch a serial execution pipeline (`split`) or the join a collection of parallel executing pipelines (`merge`).
Interestingly, the application of an `obj` to a `poly` implements the `split` instruction.
So why does an explicit `split` instruction exist?
Because there are other ways in which branching pipelines can be defined and evaluated.
This will be discussed later when discussing `fos:thread`, `fos:coroutine`, and `fos:fiber`.
====

====== Obj Application

The universal application of `.` (apply) implies that every `obj` is a function as every `obj` can have another `obj` applied to it.
This is, in fact, the case.

++++
<!-- üêñ ./main_runner.out
1.plus(1)         // <1>
1. 2              // <2>
1.2.2             // <3>
[1,2,3].<1>       // <4>
[a=>1,b=>2].b     // <5>
-->
++++

[source,mmadt]
----
fhatos> 1.plus(1)         // <1>
==>2
fhatos> 1. 2              // <2>
==>2
fhatos> 1.2.2             // <3>
==>2
fhatos> [1,2,3].<1>       // <4>
==>2
fhatos> [a=>1,b=>2].b     // <5>
==>2
----

++++
<!-- üêì -->
++++

<1> `int[1]` applied to `inst[plus(1)]`.
<2> `int[1]` applied to `int[2]` (the space before `.` is necessary to avoid parsing as a `real`).
<3> `real[1.2]` applied to `int[2]`.
<4> `lst\[[1,2,3]]` applied to the `uri[1]`.
<5> `rec\[[a=>1,b=>2]]` applied to the `uri[b]`.

[.small]
[.center]
[cols="1,1,1,1,1,1,1,1,1,1,1",width=75%]
|===
|  X   | noobj | bool | int | real | str | uri | lst | rec | inst | bcode
|noobj |    x  |  y   |    z| a    |  b  |  c  |  d  |  e  |  f   |  g
|bool  |    x  |   y  |   z |  a   |   b |   c |   d |   e |   f  |   g
|int   |     x |  y   |  z  |   a  | b   | c   |  d  | e   |  f   |    g
|real  |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|str   |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|uri   |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|lst   |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|rec   |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|inst  |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g
|bcode |    x  |   y  |  z  |    a |  b  |  c  |   d |  e  |   f  |    g

|===

==== Values

===== By Value vs. By Reference

[cols="2,2"]
|===
a|
[source,mmadt]
----
age[45]@x => plus(10) => age[55]@x
    ^                        ^
   @\|                        \|
    x------------------------/
   *\|
    v
age[45]  =>  plus(10) => age[55]
----
a|

++++
<!-- üêñ ./main_runner.out
age -> \|(is(gt(0)).is(lt(120)))
a -> age[45]
*a.inspect()
@a.inspect()
-->
++++

[source,mmadt]
----
fhatos> age -> \|(is(gt(0)).is(lt(120)))
==>is?noobj<=obj(gt?noobj<=obj(0)[noobj])[noobj].is?noobj<=obj(lt?noobj<=obj(120)[noobj])[noobj]
fhatos> a -> age[45]
==>age[45]
fhatos> *a.inspect()
[ERROR] [/mmadt/bcode] 45 is not a /mmadt/bcode as defined by [bcode][_]
fhatos> @a.inspect()
[ERROR] [/mmadt/bcode] 45@a is not a /mmadt/bcode as defined by [bcode][_]
----

++++
<!-- üêì -->
++++

|===

++++
<!-- üêñ ./main_runner.out "a?sub -> |print(_)" "a -> 12" "@a.inspect()" "@a.plus(1)" "@a.plus(1).plus(1)" -->
++++

[source,mmadt]
----
fhatos> a?sub -> |print(_)
==>print?noobj<=obj(_)[noobj]
fhatos> a -> 12
==>12
12fhatos> @a.inspect()
=>[
==>type=>[
===>id=>/mmadt/int
===>obj=>[int][_]
===>dom=>[id=>/mmadt/obj,coeff=>[1,1]]
===>rng=>[id=>/mmadt/int,coeff=>[1,1]]
=>]
==>value=>[
===>id=>a
===>obj=>12
===>encoding=>int32_t
=>]
==>sub=>a(type=>_)[cpp]
=>]
12@afhatos> @a.plus(1)
==>13@a
13@afhatos> @a.plus(1).plus(1)
==>15@a
----

++++
<!-- üêì -->
++++

==== Types

Every mmADT `obj` is typed.
A type is an mmADT `obj`.
A `obj` can serve as a value in one situation and as a type in another.
Types can be typed.

The following examples are presented using the generally useful types from the `/mmadt/ext` prefix.

++++
<!-- üêñ ./main_runner.out "*/mmadt/ext/#/" -->
++++

[source,mmadt]
----
fhatos> */mmadt/ext/#/
=>[
==>/mmadt/ext/C=>C()[is(gte(-273.149994))]
==>/mmadt/ext/Ox=>Ox()[is(true)]
==>/mmadt/ext/char=>char()[merge(2).count().is(eq(1))]
==>/mmadt/ext/int16=>[int16][_]
==>/mmadt/ext/int32=>[int32][_]
==>/mmadt/ext/int8=>uint8()[is(gte(-127)).is(lte(128))]
==>/mmadt/ext/ms=>[int][_]
==>/mmadt/ext/nat=>nat()[is(gte(0))]
==>/mmadt/ext/prnt=>prnt()[is(gte(0.000000)).is(lte(100.000000))]
==>/mmadt/ext/sec=>[int][_]
==>/mmadt/ext/secret=>[str][_]
==>/mmadt/ext/secret/::/mmadt/as=>as(from(0?type,noobj)[cpp])[cpp]
==>/mmadt/ext/uint8=>uint8()[is(gte(0)).is(lte(255))]
=>]
----

++++
<!-- üêì -->
++++

When an mm-ADT base type is wrapped in a latexmath:[\texttt{type}[\]]-bracket, the type is first resolved to it's `inst` form and then the base value `obj` is applied to it.
If the result of the application yields an `error` or a `noobj`, then the base value `obj` is not of that type and a type `error` is thrown.
However, should any other `obj` be returned, then the base value `obj` is of that type and is returned wrapped in the respective  latexmath:[\texttt{type}[\]]-bracket.
The type evaluation can be understood as a predicate, where `false` is `error` or `noobj`, otherwise `true`.
Finally, if the `obj` has a latexmath:[\texttt{@}]-reference, then any subsequent mutations to that `obj` must continue to satisfy the constraints of the type.
If any mutation falls outside the bounds of the type, a type `error` is thrown.
The `@`-reference ensures that as the `obj` mutates, it's corresponding representation in the underlying fURI structure legally mutates as well.

[tabs]
====
char::
+
--
++++
<!-- üêñ ./main_runner.out
[HEADER] .char icon:link[link=https://en.wikipedia.org/wiki/Character_(computing),2x,role=blue]
*char
char['a']@a
char['b']@b
@a + @b
*a
@a.as(str) + @b
-->
++++

.char icon:link[link=https://en.wikipedia.org/wiki/Character_(computing),2x,role=blue]
[source,mmadt]
----
fhatos> *char
==>char?int<=str()[merge(2).count().is(eq(1))]
fhatos> char['a']@a
==>char['a']@a
fhatos> char['b']@b
==>char['b']@b
fhatos> @a + @b
[ERROR] [/sys/type] 'aa'@a is not a /mmadt/ext/char as defined by char()[merge(2).count().is(eq(1))]
	  thrown at inst char['a']@a => plus(at(b))[cpp] [0=>char['a']@a]
fhatos> *a
==>char['a']@a
fhatos> @a.as(str) + @b
==>'aa'@a
----

++++
<!-- üêì -->
++++

--
nat::
+
--
++++
<!-- üêñ ./main_runner.out
[HEADER] .nat icon:link[link=https://en.wikipedia.org/wiki/Natural_number,2x,role=blue]
*nat
nat[12]
nat[-30]
nat[12]@a
@a.minus(11)
@a.minus(2)
*a
-->
++++

.nat icon:link[link=https://en.wikipedia.org/wiki/Natural_number,2x,role=blue]
[source,mmadt]
----
fhatos> *nat
==>nat?int<=int()[is(gte(0))]
fhatos> nat[12]
==>nat[12]
fhatos> nat[-30]
[ERROR] [/sys/type] -30 is not a /mmadt/ext/nat as defined by nat()[is(gte(0))]
fhatos> nat[12]@a
==>nat[12]@a
fhatos> @a.minus(11)
==>nat[1]@a
fhatos> @a.minus(2)
[ERROR] [/sys/type] -1@a is not a /mmadt/ext/nat as defined by nat()[is(gte(0))]
	  thrown at inst nat[1]@a => minus(2)[cpp] [0=>2]
fhatos> *a
==>nat[1]@a
----

++++
<!-- üêì -->
++++
--
celsius::
+
--
++++
<!-- üêñ ./main_runner.out
[HEADER] .celsius icon:link[link=https://en.wikipedia.org/wiki/Celsius,2x,role=blue]
*C
C[0.0]
C[274.0]
C[-274.0]
-->
++++

.celsius icon:link[link=https://en.wikipedia.org/wiki/Celsius,2x,role=blue]
[source,mmadt]
----
fhatos> *C
==>C?real<=real()[is(gte(-273.149994))]
fhatos> C[0.0]
==>C[0]
fhatos> C[274.0]
==>C[274]
fhatos> C[-274.0]
[ERROR] [/sys/type] -274.000000 is not a /mmadt/ext/C as defined by C()[is(gte(-273.149994))]
----

++++
<!-- üêì -->
++++
--

====

===== Bytecode and Instruction Types

===== User Defined Types

image:ginger.png[width=140,float=left]  mm-ADT is a structurally typed language, whereby if an `obj` *A* __matches__ `obj` *B*, then *A* is _a type of_ *B*.
An `obj` type is a simply an mm-ADT program that verifies instances of the type.
For instance, if a natural number stem:[\mathbb{N}] is any non-negative number, then natural numbers are a subset (or refinement) of `int`.

++++
<!-- üêñ ./main_runner.out "/type/int/nat -> |is(gt(0))" "nat[6]" "nat[-6]" "nat[3].plus(2)" "nat[3].mult(-2)" -->
++++

[source,mmadt]
----
fhatos> /type/int/nat -> |is(gt(0))
[ERROR] [/sys/router] no mounted structure for /type/int/nat  
==>is?noobj<=obj(gt?noobj<=obj(0)[noobj])[noobj]
fhatos> nat[6]
==>nat[6]
fhatos> nat[-6]
[ERROR] [/sys/type] -6 is not a /mmadt/ext/nat as defined by nat()[is(gte(0))]
fhatos> nat[3].plus(2)
==>nat[5]
fhatos> nat[3].mult(-2)
[ERROR] [/sys/type] -6 is not a /mmadt/ext/nat as defined by nat()[is(gte(0))]
	  thrown at inst nat[3] => mult(-2)[cpp] [0=>-2]
----

++++
<!-- üêì -->
++++

===== Process Types

A simple mm-ADT program is defined below.
The program is a specialization of the poly-type `rec` called `thread`, where `thread` is abstractly defined as

++++
<!-- ./main_runner.out
threadx[[ /
  halt=>false, /
  delay=>nat[0], /
  loop=>from(|a,0).plus(1).to(a).print(_). /
         [is(gt(10)) => |true.to(abc/halt)]>-]]@abc
@abc.spawn()
-->
++++

The `thread` object is published to the fURI endpoint `esp32@127.0.0.1/scheduler/threads/logger`.
The scheduler spawns the program on an individual `thread` accessible via the target fURI.
Once spawned, the `setup` function prints the thread's id and halts.

++++
<!-- #############################################################################################################
     #############################################################################################################
     ############################################ ROUTER #########################################################
     #############################################################################################################
     ############################################################################################################# -->
++++

=== The Router Structure

image:cooties-2.png[width=140,float=right] Every fhatOS machine has a single _router_.
The function of the router is to:

. Route read/write requests to respective structures.
. Coordinate with remote routers on remote read/write requests.
. Manage pattern conflicts between structures.
. Manage fURI query extensions (`?` modulators).

++++
<!-- üêñ ./main_runner.out "/io/console/config/nest->3" "*/sys/router/#/" -->
++++

[source,mmadt]
----
fhatos> /io/console/config/nest->3
==>3
fhatos> */sys/router/#/
=>[
==>/sys/router=>[
===>structure=>[
====>/sys/#
====>/mnt/#
====>/boot/#
====>/fos/#
====>/mmadt/#
====>/io/#
====>+/#
====>/disk/#
====>/shared/#
====>/bus/#
==>]
===>frame=>[rec][_]
===>config=>[
====>resolve=>[namespace=>[:=>/mmadt/,fos:=>/fos/],auto_prefix=>[,/mmadt/,/mmadt/ext/,/fos/,/fos/sys/,/fos/io/,/fos/sensor/,/fos/ui/,/fos/util/,/sys/],query=>[write=>[lock=>to_do]],default_config=>[query=>[write=>[sub=>noobj]]]]
==>]
===>query=>[
====>write=>[lock=>lock?obj{?}<=obj{?}()[cpp],sub=>sub?obj{?}<=obj()[cpp]]
==>]
=>]@/sys/router
=>]
----

++++
<!-- üêì -->
++++

The router manages access to physical memory.
Physical memory is partitioned by *structures*.
The address space of a structure is the (query-less) fURI.
Structures have an associated *pattern* fURI defining the boundaries of their storage space.
Structures can not have overlapping address spaces.
Every structure implements the `structure.hpp` and ultimately, is an `obj`.

- There are structures that encode `objs` in physical memory (e.g. `heap`).
- There are structures that encode `objs` on disk (e.g. `fs` -- filesystem).
- There are structures that encode `objs` on a remote broker (e.g. `mqtt`).
- There are structures that encode `objs` in the Bluetooth hierarchy (e.g. `bt`).
- There are structures that encode `objs` on RFID chips (e.g. `rfid`).
- There are structures that encode `objs` as scoped variables when evaluating code (e.g. `frame`).
- There are structures that encode other structures (e.g. `mnt`).

The aggregate of all structures accessible through the router defines the complete memory footprint of a [blue]*F*‚Äã[red]#H#‚Äã[aqua]*a*‚Äã[yellow]#t#‚Äã[lime]#O#‚Äã[fuchsia]*s*‚Äã instance.

++++
<!-- üêñ ./main_runner.out
a -> 'snowbutt'            --- <1>
*a                         --- <2>
a?sub -> |to(b)            --- <3>
*a?sub                     --- <4>
a -> 'meangirl'            --- <5>
*b                         --- <6>
-->
++++

[source,mmadt]
----
fhatos> a -> 'snowbutt'            // <1>
==>'snowbutt'
fhatos> *a                         // <2>
==>'snowbutt'
fhatos> a?sub -> |to(b)            // <3>
==>to?noobj<=obj(b)[noobj]
fhatos> *a?sub                     // <4>
==>a?bool<=obj(type=>_)[cpp]
fhatos> a -> 'meangirl'            // <5>
==>'meangirl'
fhatos> *b                         // <6>
==>'meangirl'
----

++++
<!-- üêì -->
++++

<1> A request to write `str['snowbutt']` to `uri[a]` is sent to the router.
<2> A request to read the `obj` at `uri[a]` is sent to the router.
<3> A subscription request to receive notifications about `uri[a]` is sent to the router.
<4> A request to read the subscriptions of `uri[a]` is sent to the router.
<5> A request to write `str['meangirl']` to `uri[a]` is sent to the router.
<6> A request to read `uri[b]` is sent to the router.

The above example makes salient the router's role is structure usage.
Not only are read/write requests managed by the router, but also subscriptions and the evaluation of their associated `on_recv`-code.
However, ultimately, the router serves as a simple singleton proxy to the structures it manages.
It's in the structures where the heavily lifting of the memory operations takes place.

==== Structure Reading and Writing

Every structure supports 2 primary operations:

[.center]
[cols="2,2",width=75%]
|===
a|

\$\text{read} : U \rightarrow O\$

The router is given a fURI `u` from `U`.
The router locates the `structure` responsible for the fURI subspace containing `u`.
The `structure` resolves `u` to an `obj`. If no `obj` is found, `noobj` is returned.

a|
++++
<!-- üêñ ./main_runner.out
[HIDDEN] u -> 'fhatos'
from(u)
*u
-->
++++

[source,mmadt]
----
fhatos> from(u)
==>'fhatos'
fhatos> *u
==>'fhatos'
----

++++
<!-- üêì -->
++++

a|
\$\text{write}: (U \times O) \rightarrow \emptyset\$

a|
++++
<!-- üêñ ./main_runner.out
u -> o
u.ref(o)
o.to(u)
-->
++++

[source,mmadt]
----
fhatos> u -> o
==>o
fhatos> u.ref(o)
==>o
fhatos> o.to(u)
==>o
----

++++
<!-- üêì -->
++++
|===

A read accepts a direct fURI (called an `id`) or a match fURI (called a `pattern`).
Within the category of `id` and `pattern`, there are `node` fURIs and `branch` fURIs.
An example itemization is provided below:

* `id`: an unambiguous fURI that references a single address space in the structure.
** `node`: the address of a specific `obj`.
** `branch`: the root address of a collection of `objs`.
* `pattern`: a fURI containing one or more wildcard characters (`+` or `#`) in it's path.
** `node`: a pattern referencing zero or more `objs`.
** `branch`: a pattern referencing zero or more collections of `objs`.

[cols="3,5"]
|===

a|
++++
<!-- üêñ ./main_runner.out
a/a -> 1; a/b -> 2; a/b/c -> 3; a/b/d -> 4;
*a/b            --- <1>
*a/b/           --- <2>
*a/+            --- <3>
*a/+/           --- <4>
*a/#            --- <5>
*a/#/           --- <6>
-->
++++

[source,mmadt]
----
fhatos> a/a -> 1; a/b -> 2; a/b/c -> 3; a/b/d -> 4;
fhatos> *a/b            // <1>
==>2
fhatos> *a/b/           // <2>
=>[
==>a/b/c=>3
==>a/b/d=>4
=>]
fhatos> *a/+            // <3>
==>1
==>2
fhatos> *a/+/           // <4>
=>[
==>a/b/c=>3
==>a/b/d=>4
=>]
fhatos> *a/#            // <5>
==>1
==>2
==>3
==>4
fhatos> *a/#/           // <6>
=>[
==>a/a=>1
==>a/b=>2
==>a/b/c=>3
==>a/b/d=>4
=>]
----

++++
<!-- üêì -->
++++

a|

++++
TIP: The first line in the example appears to be 4 https://en.wikipedia.org/wiki/Pascal_(programming_language)#Semicolons_as_statement_separators[individual statements].
In fact, it is a single fluent expression. The signature of the `end` `inst` (sugar'd `;`) is `end?obj{0}\<=obj{*}`.
This barrier step computes all monads up to it before emitting a `noobj` monad.
With `end`, it's possible to write mm-ADT in the classic statement-oriented, imperative-style where semincolons (effectively) separate atomic operations.
++++

<1> Dereferencing an `id`-node fURI to access a single `obj`.
<2> Dereferencing an `id`-branch fURI to access a collection of `objs`.
<3> Dereferencing a `pattern`-node fURI to access `objs` at respective nodes.
<4> Dereferencing a `pattern`-branch fURI to access `objs` at respective branches.

|===

===== Query Processors

Every fURI can have any number of key/value(s) pairs attached to it via the `?` query encoding scheme defined by the
https://datatracker.ietf.org/doc/html/rfc3986#section-3.4[W3C URI] specification.
Modules can be added to structures enabling different behaviors on read/write given associated, relevant `?` parameters.
Example modules that come preloaded with [lime]#f#‚Äã[aqua]#h#‚Äã[fuchsia]*A*‚Äã[blue]*T*‚Äã[red]#o#‚Äã[yellow]#s#‚Äã are:

. `pubsub`: supports asynchronous, event-based access to structure `objs`.
.. `a?sub -> _` (subscribe )
.. `a?sub -> noobj` (unsubscribe)
.. `sub[source=>uri, pattern=>uri, on_recv=>obj]`
.. `msg[target=>uri, payload=>obj, retain=>bool]`
. `lock`: provides resource locking semantics to reading and writing `objs` in a concurrent environment.
.. `a?lock=w` (prevent writes to the `obj` at `a`)
.. `a?lock=rw` (prevent reads and writes to the `obj` at `a`)
.. `a?lock=false` (unlock the `obj` at `a`)
. `type`: provides an `obj` type system encoded within an `obj's` type fURI.
.. `nat?dom=int&dc=1,1&rng=int&rc=1,1` (the `inst` signature of `nat?int<=int()[...]`)

Other modules can be created and deployed across a [fuchsia]#F#‚Äã[blue]*H*‚Äã[aqua]#a#‚Äã[red]*T*‚Äã[yellow]*o*‚Äã[lime]*S*‚Äã cluster.

.Query Free fURIs
****
IMPORTANT: The address space of a structures does not include the query parameters.
Query parameters are used by structures to modulate the semantics of a read/write operation and are never used as the address of an `obj`.
However, nothing prevents the `obj` at an address to be a `uri[]` with a query.
Be sure to use the non-sugar'd `< >` fURI syntax when multiple values are associated with a key as the value separating
`,` will be preferentially parsed as a `lst`, `rec`, or `inst` argument separator.
++++
<!-- üêñ ./main_runner.out
abc?k1=v1&k2=v2&k3=v3                     --- <1>
abc?k1=v1,v2&k2=v3&k3=v4,v5,v6            --- <2>
<abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>          --- <3>
<abc?k1=v1,v2&k2=v3&k3=v4,v5,v6> -> 12    --- <4>
*abc
abc -> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>   --- <5>
*abc
-->
++++

[source,mmadt]
----
fhatos> abc?k1=v1&k2=v2&k3=v3                     // <1>
==>abc?k1=v1&k2=v2&k3=v3
fhatos> abc?k1=v1,v2&k2=v3&k3=v4,v5,v6            // <2>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>          // <3>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6> -> 12    // <4>
[ERROR] [/sys/router] [/mnt/cache] no query processor for k1=v1,v2&k2=v3&k3=v4,v5,v6 on write
==>12
fhatos> *abc
fhatos> abc -> <abc?k1=v1,v2&k2=v3&k3=v4,v5,v6>   // <5>
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
fhatos> *abc
==>abc?k1=v1,v2&k2=v3&k3=v4,v5,v6
----

++++
<!-- üêì -->
++++

<1> Sugar'd `uri` syntax can be used when no commas are present in the fURI.
<2> Multiple values are deliminated using commas.
<3> To ensure proper parsing, multi-value query `uris[]` should be wrapped in `< >` brackets.
<4> The query of a fURI is stripped when used as a structure address.
<5> The query of a fURI is not stripped when used as a value at a struture address.

****

[source,mmadt]
----
1.plus(2)
----

[cols="7,8"]
|===
a|
++++
<!-- üêñ ./main_runner.out
*a
*b
b -> 12
a -> b
*a
**a
-->
++++

[source,mmadt]
----
fhatos> *a
==>a?bool<=obj(type=>_)[cpp]
fhatos> *b
fhatos> b -> 12
==>12
fhatos> a -> b
==>b
fhatos> *a
==>b
fhatos> **a
==>12
----

++++
<!-- üêì -->
++++

a|
[source,mmadt]
----
   [‚ñ†]                         [‚ñ†]
  /   \                       /   \
 /     \                     /     \
[‚ñ†]    [‚ñ†]                  [‚ñ†]    [‚ñ†]
      /   \                       /   \
     /     \                     /     \
   [‚ñ†]     [b]@x ------------> [12]@b  [‚ñ†]
----
`b` references `12`. `a` references `b`. a double dereferences jumps the monad from `a` to `b` to `12`.
a|
++++
<!-- üêñ ./main_runner.out
a -> 12
*a.plus(10)
*a
@a
@a.plus(10)
*a
-->
++++

[source,mmadt]
----
fhatos> a -> 12
==>12
fhatos> *a.plus(10)
==>22
fhatos> *a
==>12
fhatos> @a
==>12@a
fhatos> @a.plus(10)
==>22@a
fhatos> *a
==>22@a
----

++++
<!-- üêì -->
++++

a|
[source,mmadt]
----
   [‚ñ†]                          [‚ñ†]
  /   \                        /   \
 /     \                      /     \
[‚ñ†]    [‚ñ†]                   [‚ñ†]    [‚ñ†]
      /   \                           \
     /     \         @a.plus(10)       \
   [‚ñ†]     [12]@a ------------------> [22]@a
----
`12` is written to `a`. `10` is added to `a` (*pass by value* `*`). `a` still stores `12`. `10` is added to `a` (**pass by reference** `@`). `a` now stores `22`.
a|
++++
<!-- üêñ ./main_runner.out "a?sub -> \|to(b)" "*a?sub" "*b" "a->12" "*a" "*b" -->
++++

[source,mmadt]
----
fhatos> a?sub -> \|to(b)
==>to?noobj<=obj(b)[noobj]
fhatos> *a?sub
==>a?bool<=obj(type=>_)[cpp]
fhatos> *b
fhatos> a->12
==>12
fhatos> *a
==>12
fhatos> *b
==>12
----

++++
<!-- üêì -->
++++


[source,mmadt]
----
fhatos> a?sub -> \|to(b)
[INFO]  [/mnt/cache] [/sys/scheduler]=subscribe=>[+/#]
==>to?obj<=obj(b)[noobj]
fhatos> *a?sub
fhatos> *b
fhatos> a->12
==>12
fhatos> *a
==>12
fhatos> *b
==>12

----

a|
[source,mmadt]
----
   [‚ñ†]                          [‚ñ†]
  /   \                        /   \
 /     \                      /     \
[‚ñ†]    [‚ñ†]        [sub]     [‚ñ†]     [‚ñ†]
      /   \      .     .   /   \
     /     \    .       . /     \
   [‚ñ†]     [12]@a       [12]@b  [‚ñ†]
----
subscribes to `a` with bcode of the form \$f(a) -> b\$. `12` is written to `a` which triggers the subscription bcode to write `12` to `b`.
|===

==== Embedding

mm-ADT was designed to support the creation and manipulation of _abstract data types_ -- the "ADT" in mm-ADT.
When expressing abstract data types is natural, then it's possible to leverage _multiple models_ such as key/value, document, relational, vector, graph, and the various nooks and crannies between -- the "mm" in mm-ADT.

mm-ADT's URI addressing scheme makes it possible to _embed_ an array data types into the underlying [blue]*F*‚Äã[red]#h#‚Äã[lime]*A*‚Äã[fuchsia]*T*‚Äã[yellow]*O*‚Äã[aqua]#s#‚Äã structure.
This section will explore the following considerations when designing a _multi-model abstract data type_.

. **spatial encodings**
. **schema encodings**
. **language encodings**

===== Spatial Consideration when Embedding

++++
<!-- üêñ ./main_runner.out
1.plus(2)
-->
++++

[source,mmadt]
----
fhatos> 1.plus(2)
==>3
----

++++
<!-- üêì -->
++++

A _matrix_ is an \$n \times m\$ data structure composed of \$n\$ vectors/row, each with \$m\$ elements/columns.
A relational database _table_ is an example of a matrix, where the entries typically span numeric and non-numeric data types.
Three general approaches to embedding a matrix or table into a `fos:structure` are presented below, where each makes different space/time tradeoffs.

[cols="5,5,5",separator=üß±]
|===
^aüß±
[.big]
[source,mmadt]
----
 \    |   |    /
 [‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]

 -[‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]-

 [‚ñ†] [‚ñ†] [‚ñ†] [‚ñ†]
 /    |   |    \

----
^aüß±
[.big]
[source,mmadt]
----
‚Äã
[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]

[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]

[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
‚Äã
----

^aüß±
[.big]
[source,mmadt]
----
‚Äã
[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
|   |   |   |
[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
|   |   |   |
[‚ñ†]-[‚ñ†]-[‚ñ†]-[‚ñ†]
‚Äã
----
aüß±
++++
<!-- üêñ ./main_runner.out
--- write matrix
m/0/0 -> 0
m/0/1 -> 1
m/0/2 -> 2
m/0/3 -> 3
m/1/0 -> 4
m/1/1 -> 5
m/1/2 -> 6
m/1/3 -> 7
m/2/0 -> 8
m/2/1 -> 9
m/2/2 -> 10
m/2/3 -> 11
--- read matrix
*m/0/0      --- <1>
*m/0/+      --- <2>
*m/+/0      --- <3>
-->
++++

[source,mmadt]
----
fhatos> --- write matrix
fhatos> m/0/0 -> 0
==>0
fhatos> m/0/1 -> 1
==>1
fhatos> m/0/2 -> 2
==>2
fhatos> m/0/3 -> 3
==>3
fhatos> m/1/0 -> 4
==>4
fhatos> m/1/1 -> 5
==>5
fhatos> m/1/2 -> 6
==>6
fhatos> m/1/3 -> 7
==>7
fhatos> m/2/0 -> 8
==>8
fhatos> m/2/1 -> 9
==>9
fhatos> m/2/2 -> 10
==>10
fhatos> m/2/3 -> 11
==>11
fhatos> --- read matrix
==>x
fhatos> *m/0/0      // <1>
==>0
fhatos> *m/0/+      // <2>
==>0
==>1
==>2
==>3
fhatos> *m/+/0      // <3>
==>0
==>4
==>8
----

++++
<!-- üêì -->
++++

aüß±
++++

<!-- üêñ ./main_runner.out --- write matrix m/0 -> [0,1,2,3]
m/1 -> [4,5,6,7]
m/2 -> [8,9,10,11]
--- read matrix *m/0/0 --- <1> *m/0/+ --- <2> *m/+/0 --- <3> -->

++++

[source,mmadt]
----
fhatos> --- write matrix
fhatos> m/0 -> [0,1,2,3]
=>[
===>0
===>1
===>2
===>3
=>]
fhatos> m/1 -> [4,5,6,7]
=>[
===>4
===>5
===>6
===>7
=>]
fhatos> m/2 -> [8,9,10,11]
=>[
===>8
===>9
===>10
===>11
=>]
fhatos> --- read matrix
==>x
fhatos> *m/0/0      // <1>
==>0
fhatos> *m/0/+      // <2>
==>0
==>1
==>2
==>3
fhatos> *m/+/0      // <3>
==>0
==>4
==>8
----

++++

<!-- üêì -->

++++

aüß±
++++

<!-- üêñ ./main_runner.out --- write matrix m -> [[0,1,2,3], /
[4,5,6,7], /
[8,9,10,11]]
--- read matrix *m/0/0 --- <1> *m/0/+ --- <2> *m/+/0 --- <3> -->

++++

[source,mmadt]
----
fhatos> --- write matrix
fhatos> m -> [[0,1,2,3],
              [4,5,6,7],
              [8,9,10,11]]
=>[
=>[
===>0
===>1
===>2
===>3
=>]
=>[
===>4
===>5
===>6
===>7
=>]
=>[
===>8
===>9
===>10
===>11
=>]
=>]
fhatos> --- read matrix
==>x
fhatos> *m/0/0      // <1>
==>0
fhatos> *m/0/+      // <2>
==>0
==>1
==>2
==>3
fhatos> *m/+/0      // <3>
==>0
==>4
==>8
----

++++

<!-- üêì -->

++++

|===

<1> Retrieve the first element of matrix `m`.
<2> Retrieve the first row of matrix `m`.
<3> Retrieve the first column of matrix `m`.

The above example demonstrates the power of structural embeddings.
The platonic matrix `m` was embedded in a structure using 3 different representations: _entry-wise_, _row-wise_, and _row-column wise_.
Next, each embedding was read: an _element read_, a _row read_ and a _column read_.
The expression used to read from each of the three embeddings is the same and so is the result.
This is possible because a structure resolves up the fURI path hierarchy until it finds a match.
Once found, it then traverses within the match to resolve the remaining path segments.

.Amortized Costs in Terms of Time
[.small][.center]
[%header,width=50%,cols="l2,c1,c1,c1"]
|===
| embedding              | single-element | row-access  | column-access
| [.red]#entry#          | \$O(1)\$       | \$O(n)\$    | \$O(m)\$
| [.red]#row#            | \$O(m)\$       | \$O(1)\$    | \$O(m)\$
| [.red]#row_column#     | \$O(1)\$       | \$O(1)\$    | \$O(1)\$
|===

The different embeddings also have different space costs, where space is defined as the amount of data accessed (i.e. retrieved from the structure) in order to
satisfy the resolution of the respective fURI.

.Amortized Costs in Terms of Space
[.small][.center]
[%header,width=50%,cols="l2,c1,c1,c1"]
|===
| embedding              | single-element | row-access    | column-access
| [.red]#entry#          | \$O(1)\$       | \$O(n)\$      | \$O(m)\$
| [.red]#row#            | \$O(n)\$       | \$O(n)\$      | \$O(n+m)\$
| [.red]#row_column#     | \$O(n+m)\$     | \$O(n+m)\$    | \$O(n+m)\$
|===


[source,mmadt]
----
                                    [a=>[b,c]]
                                       [‚ñ†]
          [‚ñ†]                         /   \
                              [b=>c][‚ñ†]   [‚ñ†][d=>e]

   [a=>[b=>c,d=>e]]]            [a=>[b=>c,d=>e]]]
           ^                            ^
           |                            |
           x                            x/

----

++++

<!-- ######################################################################################################## ############################################################################################################# ########################################### SCHEDULER ####################################################### ############################################################################################################# ############################################################################################################# -->

++++

=== The Scheduler Process




=== A FhatOS Console

.FhatOS Console
****
The [fuchsia]#F#‚Äã[lime]*h*‚Äã[red]*a*‚Äã[aqua]#T#‚Äã[yellow]*o*‚Äã[blue]*S*‚Äã Console is a composite of 3 other actors:

. The `Terminal` (`/sys/io/terminal/`) provides thread-safe access to hardware I/O.
. The `Parser` (`/sys/lang/parser/`) converts string input to bytecode output.
. The `Processor` (`/sys/lang/processor/`) executes bytecode.
****

=== fURI and MQTT

https://en.wikipedia.org/wiki/MQTT[MQTT] is a publish/subscribe message passing protocol that has found extensive usage in embedded systems.
Hierarchically specified _topics_ can be **subscribed** and **published** to.
In MQTT, there is no direct communication between actors, though such behavior can be simulated if an actor's mailbox is a unique topic.
[fuchsia]#f#‚Äã[yellow]*h*‚Äã[blue]*A*‚Äã[lime]*T*‚Äã[red]#o#‚Äã[aqua]*S*‚Äã leverages MQTT, but from the vantage point of URIs instead of topics with message routing being location-aware.
There exist three MQTT routers:

. `MonadRouter`: An MQTT router scoped to an active monad (**thread**) processing a monoid (**program**).
. `MonoidRouter`: An MQTT router scoped to a monoid (**program**).
. `HostRouter`: An MQTT router scoped to the current host (**machine**).
. `ClusterRouter`: An MQTT router scoped to the current intranet (**cluster**).
. `GlobalRouter` : An MQTT router scoped to the Internet.
. `MetaRouter`: An MQTT router dynamically scoped to other routers based on fURI endpoints.

.fURI Router Scope Patterns
****
TIP: The more `/` in the fURI prefix, the more distributed the fURI repeat.
* `abc` monad scoped fURI.
* `~/abc` monoid scoped fURI ("home directory" of executing program).
* `/abc` host scoped fURI (rooted at `localhost`).
* `//abc` cluster scoped fURI (hosted on the intranet).
* `//fhatos.org/abc` globally scoped fURI (hosted on the internet)
****

.Monoid power method
[latexmath]
++++

M = aM

++++

++++

<!-- üêñ ./main_runner.out
{1,2,3}
{1,2,3}.plus(10)
{1,2,3}.plus(_)
{1,2,3}.plus(plus(_)) -->

++++

[source,mmadt,subs="-replacements"]
----
fhatos> {1,2,3}
==>1
==>2
==>3
fhatos> {1,2,3}.plus(10)
==>11
==>12
==>13
fhatos> {1,2,3}.plus(_)
==>2
==>4
==>6
fhatos> {1,2,3}.plus(plus(_))
==>3
==>6
==>9
----

++++

<!-- üêì -->

++++

== FhatOS Modules

=== Kernel Modules

==== mmADT Module (mmadt)

===== Type Module (mmadt:type)

===== Parser Module (mmadt:parser)

==== Scheduler Module (scheduler)

==== Router Module (router)

=== Core Modules

==== Pin Modules

===== GPIO (gpio)

Hardware devices with digital general purpose input/output (GPIO) can be manipulated with `/fos/io/gpio`.

===== PWM (pwm)

Pins that support pulse-wave modulation can be manipulated with `/fos/io/pwm`.

===== i2c (i2c)

Two wire access

==== FileSystem Module (fs)

==== Terminal Module (terminal)

==== REPL Module (repl)

==== Logging Module (log)

=== Embedded Systems Modules

==== Sensors

==== Actuators

== Reference

=== mm-ADT Core Instructions

==== as `[_]`

==== block `|`

==== is

==== plus

++++

<!-- üêñ ./main_runner.out "true.plus(false)" "1.plus(2)" "'a'.plus('b')" -->

++++

[source,mmadt,subs="-replacements"]
----
fhatos> true.plus(false)
==>true
fhatos> 1.plus(2)
==>3
fhatos> 'a'.plus('b')
==>'ab'
----

++++

<!-- üêì -->

++++

==== mult

==== mod

==== lift `^`

==== drop `v`

==== split `-<`

==== each `=`

==== within `\_/ \_`

==== merge `>-`

==== from `*`

==== to `\->`

==== get `@`

==== pass `-\->`

==== match `~`

++++

<!-- üêñ ./main_runner.out "[a=>2].match([a=>3])" "[a=>2].match([a=>_])" -->

++++

[source,mmadt,subs="-replacements"]
----
fhatos> [a=>2].match([a=>3])
[ERROR] [/mmadt/rec] match inst unresolved 
	         lhs id      inst id    resolve obj
	  ->[/mmadt/rec] match => noobj
	 -->[/mmadt/rec] match => noobj
	--->[          ] match => noobj
fhatos> [a=>2].match([a=>_])
[ERROR] [/mmadt/rec] match inst unresolved 
	         lhs id      inst id    resolve obj
	  ->[/mmadt/rec] match => noobj
	 -->[/mmadt/rec] match => noobj
	--->[          ] match => noobj
----

++++

<!-- üêì -->

++++

==== eq

==== neq

==== gt

==== lt

==== gte

==== lte

== FhatOS Types

=== Process Types

==== thread

==== fiber

==== coroutine

=== PubSub Types

==== sub

[source,mmadt]
----
sub[[:source=>_, :pattern=>_, :on_recv=>bcode[_]]]
----

==== msg

[source,mmadt]
----
msg[[:target=>uri[_], :payload=>_, :retain=>bool[_]]]
----
